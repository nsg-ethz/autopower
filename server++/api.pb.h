// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/timestamp.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_api_2eproto;
namespace autopapi {
class authClientUid;
struct authClientUidDefaultTypeInternal;
extern authClientUidDefaultTypeInternal _authClientUid_default_instance_;
class clientResponse;
struct clientResponseDefaultTypeInternal;
extern clientResponseDefaultTypeInternal _clientResponse_default_instance_;
class clientUid;
struct clientUidDefaultTypeInternal;
extern clientUidDefaultTypeInternal _clientUid_default_instance_;
class cmMCode;
struct cmMCodeDefaultTypeInternal;
extern cmMCodeDefaultTypeInternal _cmMCode_default_instance_;
class mgmtAuth;
struct mgmtAuthDefaultTypeInternal;
extern mgmtAuthDefaultTypeInternal _mgmtAuth_default_instance_;
class mgmtMsmtSettings;
struct mgmtMsmtSettingsDefaultTypeInternal;
extern mgmtMsmtSettingsDefaultTypeInternal _mgmtMsmtSettings_default_instance_;
class mgmtRequest;
struct mgmtRequestDefaultTypeInternal;
extern mgmtRequestDefaultTypeInternal _mgmtRequest_default_instance_;
class msmtName;
struct msmtNameDefaultTypeInternal;
extern msmtNameDefaultTypeInternal _msmtName_default_instance_;
class msmtSample;
struct msmtSampleDefaultTypeInternal;
extern msmtSampleDefaultTypeInternal _msmtSample_default_instance_;
class msmtSettings;
struct msmtSettingsDefaultTypeInternal;
extern msmtSettingsDefaultTypeInternal _msmtSettings_default_instance_;
class nothing;
struct nothingDefaultTypeInternal;
extern nothingDefaultTypeInternal _nothing_default_instance_;
class registrationStatus;
struct registrationStatusDefaultTypeInternal;
extern registrationStatusDefaultTypeInternal _registrationStatus_default_instance_;
class sampleAck;
struct sampleAckDefaultTypeInternal;
extern sampleAckDefaultTypeInternal _sampleAck_default_instance_;
class srvRequest;
struct srvRequestDefaultTypeInternal;
extern srvRequestDefaultTypeInternal _srvRequest_default_instance_;
}  // namespace autopapi
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace autopapi {
enum srvRequestType : int {
  INTRODUCE_SERVER = 0,
  START_MEASUREMENT = 1,
  STOP_MEASUREMENT = 2,
  REQUEST_MEASUREMENT_LIST = 3,
  REQUEST_MEASUREMENT_DATA = 4,
  REQUEST_MEASUREMENT_STATUS = 5,
  REQUEST_AVAILABLE_PP_DEVICE = 6,
  srvRequestType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  srvRequestType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool srvRequestType_IsValid(int value);
extern const uint32_t srvRequestType_internal_data_[];
constexpr srvRequestType srvRequestType_MIN = static_cast<srvRequestType>(0);
constexpr srvRequestType srvRequestType_MAX = static_cast<srvRequestType>(6);
constexpr int srvRequestType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
srvRequestType_descriptor();
template <typename T>
const std::string& srvRequestType_Name(T value) {
  static_assert(std::is_same<T, srvRequestType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to srvRequestType_Name().");
  return srvRequestType_Name(static_cast<srvRequestType>(value));
}
template <>
inline const std::string& srvRequestType_Name(srvRequestType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<srvRequestType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool srvRequestType_Parse(absl::string_view name, srvRequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<srvRequestType>(
      srvRequestType_descriptor(), name, value);
}
enum clientResponseType : int {
  INTRODUCE_CLIENT = 0,
  STARTED_MEASUREMENT_RESPONSE = 1,
  STOPPED_MEASUREMENT_RESPONSE = 2,
  MEASUREMENT_LIST_RESPONSE = 3,
  MEASUREMENT_DATA_RESPONSE = 4,
  MEASUREMENT_STATUS_RESPONSE = 5,
  MEASUREMENT_PP_DEVICE_RESPONSE = 6,
  clientResponseType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  clientResponseType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool clientResponseType_IsValid(int value);
extern const uint32_t clientResponseType_internal_data_[];
constexpr clientResponseType clientResponseType_MIN = static_cast<clientResponseType>(0);
constexpr clientResponseType clientResponseType_MAX = static_cast<clientResponseType>(6);
constexpr int clientResponseType_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
clientResponseType_descriptor();
template <typename T>
const std::string& clientResponseType_Name(T value) {
  static_assert(std::is_same<T, clientResponseType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to clientResponseType_Name().");
  return clientResponseType_Name(static_cast<clientResponseType>(value));
}
template <>
inline const std::string& clientResponseType_Name(clientResponseType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<clientResponseType_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool clientResponseType_Parse(absl::string_view name, clientResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<clientResponseType>(
      clientResponseType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class srvRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.srvRequest) */ {
 public:
  inline srvRequest() : srvRequest(nullptr) {}
  ~srvRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR srvRequest(::google::protobuf::internal::ConstantInitialized);

  inline srvRequest(const srvRequest& from)
      : srvRequest(nullptr, from) {}
  srvRequest(srvRequest&& from) noexcept
    : srvRequest() {
    *this = ::std::move(from);
  }

  inline srvRequest& operator=(const srvRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline srvRequest& operator=(srvRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const srvRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const srvRequest* internal_default_instance() {
    return reinterpret_cast<const srvRequest*>(
               &_srvRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(srvRequest& a, srvRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(srvRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(srvRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  srvRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<srvRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const srvRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const srvRequest& from) {
    srvRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(srvRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.srvRequest";
  }
  protected:
  explicit srvRequest(::google::protobuf::Arena* arena);
  srvRequest(::google::protobuf::Arena* arena, const srvRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kRequestBodyFieldNumber = 3,
    kMsgTypeFieldNumber = 2,
    kRequestNoFieldNumber = 4,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // optional string requestBody = 3;
  bool has_requestbody() const;
  void clear_requestbody() ;
  const std::string& requestbody() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestbody(Arg_&& arg, Args_... args);
  std::string* mutable_requestbody();
  PROTOBUF_NODISCARD std::string* release_requestbody();
  void set_allocated_requestbody(std::string* value);

  private:
  const std::string& _internal_requestbody() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestbody(
      const std::string& value);
  std::string* _internal_mutable_requestbody();

  public:
  // .autopapi.srvRequestType msgType = 2;
  void clear_msgtype() ;
  ::autopapi::srvRequestType msgtype() const;
  void set_msgtype(::autopapi::srvRequestType value);

  private:
  ::autopapi::srvRequestType _internal_msgtype() const;
  void _internal_set_msgtype(::autopapi::srvRequestType value);

  public:
  // uint32 requestNo = 4;
  void clear_requestno() ;
  ::uint32_t requestno() const;
  void set_requestno(::uint32_t value);

  private:
  ::uint32_t _internal_requestno() const;
  void _internal_set_requestno(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:autopapi.srvRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr requestbody_;
    int msgtype_;
    ::uint32_t requestno_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class sampleAck final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.sampleAck) */ {
 public:
  inline sampleAck() : sampleAck(nullptr) {}
  ~sampleAck() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR sampleAck(::google::protobuf::internal::ConstantInitialized);

  inline sampleAck(const sampleAck& from)
      : sampleAck(nullptr, from) {}
  sampleAck(sampleAck&& from) noexcept
    : sampleAck() {
    *this = ::std::move(from);
  }

  inline sampleAck& operator=(const sampleAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline sampleAck& operator=(sampleAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const sampleAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const sampleAck* internal_default_instance() {
    return reinterpret_cast<const sampleAck*>(
               &_sampleAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(sampleAck& a, sampleAck& b) {
    a.Swap(&b);
  }
  inline void Swap(sampleAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(sampleAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  sampleAck* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<sampleAck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const sampleAck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const sampleAck& from) {
    sampleAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(sampleAck* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.sampleAck";
  }
  protected:
  explicit sampleAck(::google::protobuf::Arena* arena);
  sampleAck(::google::protobuf::Arena* arena, const sampleAck& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSampleIdFieldNumber = 1,
  };
  // uint64 sampleId = 1;
  void clear_sampleid() ;
  ::uint64_t sampleid() const;
  void set_sampleid(::uint64_t value);

  private:
  ::uint64_t _internal_sampleid() const;
  void _internal_set_sampleid(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:autopapi.sampleAck)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t sampleid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class registrationStatus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.registrationStatus) */ {
 public:
  inline registrationStatus() : registrationStatus(nullptr) {}
  ~registrationStatus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR registrationStatus(::google::protobuf::internal::ConstantInitialized);

  inline registrationStatus(const registrationStatus& from)
      : registrationStatus(nullptr, from) {}
  registrationStatus(registrationStatus&& from) noexcept
    : registrationStatus() {
    *this = ::std::move(from);
  }

  inline registrationStatus& operator=(const registrationStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline registrationStatus& operator=(registrationStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const registrationStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const registrationStatus* internal_default_instance() {
    return reinterpret_cast<const registrationStatus*>(
               &_registrationStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(registrationStatus& a, registrationStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(registrationStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(registrationStatus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  registrationStatus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<registrationStatus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const registrationStatus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const registrationStatus& from) {
    registrationStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(registrationStatus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.registrationStatus";
  }
  protected:
  explicit registrationStatus(::google::protobuf::Arena* arena);
  registrationStatus(::google::protobuf::Arena* arena, const registrationStatus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kRegStatusFieldNumber = 2,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // string regStatus = 2;
  void clear_regstatus() ;
  const std::string& regstatus() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_regstatus(Arg_&& arg, Args_... args);
  std::string* mutable_regstatus();
  PROTOBUF_NODISCARD std::string* release_regstatus();
  void set_allocated_regstatus(std::string* value);

  private:
  const std::string& _internal_regstatus() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regstatus(
      const std::string& value);
  std::string* _internal_mutable_regstatus();

  public:
  // @@protoc_insertion_point(class_scope:autopapi.registrationStatus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      54, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr regstatus_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class nothing final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:autopapi.nothing) */ {
 public:
  inline nothing() : nothing(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR nothing(::google::protobuf::internal::ConstantInitialized);

  inline nothing(const nothing& from)
      : nothing(nullptr, from) {}
  nothing(nothing&& from) noexcept
    : nothing() {
    *this = ::std::move(from);
  }

  inline nothing& operator=(const nothing& from) {
    CopyFrom(from);
    return *this;
  }
  inline nothing& operator=(nothing&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const nothing& default_instance() {
    return *internal_default_instance();
  }
  static inline const nothing* internal_default_instance() {
    return reinterpret_cast<const nothing*>(
               &_nothing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(nothing& a, nothing& b) {
    a.Swap(&b);
  }
  inline void Swap(nothing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(nothing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  nothing* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<nothing>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const nothing& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const nothing& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.nothing";
  }
  protected:
  explicit nothing(::google::protobuf::Arena* arena);
  nothing(::google::protobuf::Arena* arena, const nothing& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:autopapi.nothing)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class msmtSettings final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.msmtSettings) */ {
 public:
  inline msmtSettings() : msmtSettings(nullptr) {}
  ~msmtSettings() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR msmtSettings(::google::protobuf::internal::ConstantInitialized);

  inline msmtSettings(const msmtSettings& from)
      : msmtSettings(nullptr, from) {}
  msmtSettings(msmtSettings&& from) noexcept
    : msmtSettings() {
    *this = ::std::move(from);
  }

  inline msmtSettings& operator=(const msmtSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline msmtSettings& operator=(msmtSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const msmtSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const msmtSettings* internal_default_instance() {
    return reinterpret_cast<const msmtSettings*>(
               &_msmtSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(msmtSettings& a, msmtSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(msmtSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(msmtSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  msmtSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<msmtSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const msmtSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const msmtSettings& from) {
    msmtSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(msmtSettings* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.msmtSettings";
  }
  protected:
  explicit msmtSettings(::google::protobuf::Arena* arena);
  msmtSettings(::google::protobuf::Arena* arena, const msmtSettings& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kPpDeviceFieldNumber = 3,
    kPpSamplingIntervalFieldNumber = 4,
    kUploadIntervalMinFieldNumber = 5,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // string ppDevice = 3;
  void clear_ppdevice() ;
  const std::string& ppdevice() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ppdevice(Arg_&& arg, Args_... args);
  std::string* mutable_ppdevice();
  PROTOBUF_NODISCARD std::string* release_ppdevice();
  void set_allocated_ppdevice(std::string* value);

  private:
  const std::string& _internal_ppdevice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ppdevice(
      const std::string& value);
  std::string* _internal_mutable_ppdevice();

  public:
  // string ppSamplingInterval = 4;
  void clear_ppsamplinginterval() ;
  const std::string& ppsamplinginterval() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ppsamplinginterval(Arg_&& arg, Args_... args);
  std::string* mutable_ppsamplinginterval();
  PROTOBUF_NODISCARD std::string* release_ppsamplinginterval();
  void set_allocated_ppsamplinginterval(std::string* value);

  private:
  const std::string& _internal_ppsamplinginterval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ppsamplinginterval(
      const std::string& value);
  std::string* _internal_mutable_ppsamplinginterval();

  public:
  // uint32 uploadIntervalMin = 5;
  void clear_uploadintervalmin() ;
  ::uint32_t uploadintervalmin() const;
  void set_uploadintervalmin(::uint32_t value);

  private:
  ::uint32_t _internal_uploadintervalmin() const;
  void _internal_set_uploadintervalmin(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:autopapi.msmtSettings)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 0,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr ppdevice_;
    ::google::protobuf::internal::ArenaStringPtr ppsamplinginterval_;
    ::uint32_t uploadintervalmin_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class msmtName final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.msmtName) */ {
 public:
  inline msmtName() : msmtName(nullptr) {}
  ~msmtName() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR msmtName(::google::protobuf::internal::ConstantInitialized);

  inline msmtName(const msmtName& from)
      : msmtName(nullptr, from) {}
  msmtName(msmtName&& from) noexcept
    : msmtName() {
    *this = ::std::move(from);
  }

  inline msmtName& operator=(const msmtName& from) {
    CopyFrom(from);
    return *this;
  }
  inline msmtName& operator=(msmtName&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const msmtName& default_instance() {
    return *internal_default_instance();
  }
  static inline const msmtName* internal_default_instance() {
    return reinterpret_cast<const msmtName*>(
               &_msmtName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(msmtName& a, msmtName& b) {
    a.Swap(&b);
  }
  inline void Swap(msmtName* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(msmtName* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  msmtName* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<msmtName>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const msmtName& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const msmtName& from) {
    msmtName::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(msmtName* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.msmtName";
  }
  protected:
  explicit msmtName(::google::protobuf::Arena* arena);
  msmtName(::google::protobuf::Arena* arena, const msmtName& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // string name = 2;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // @@protoc_insertion_point(class_scope:autopapi.msmtName)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class mgmtRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.mgmtRequest) */ {
 public:
  inline mgmtRequest() : mgmtRequest(nullptr) {}
  ~mgmtRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR mgmtRequest(::google::protobuf::internal::ConstantInitialized);

  inline mgmtRequest(const mgmtRequest& from)
      : mgmtRequest(nullptr, from) {}
  mgmtRequest(mgmtRequest&& from) noexcept
    : mgmtRequest() {
    *this = ::std::move(from);
  }

  inline mgmtRequest& operator=(const mgmtRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline mgmtRequest& operator=(mgmtRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mgmtRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const mgmtRequest* internal_default_instance() {
    return reinterpret_cast<const mgmtRequest*>(
               &_mgmtRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(mgmtRequest& a, mgmtRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(mgmtRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mgmtRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mgmtRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mgmtRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const mgmtRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const mgmtRequest& from) {
    mgmtRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(mgmtRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.mgmtRequest";
  }
  protected:
  explicit mgmtRequest(::google::protobuf::Arena* arena);
  mgmtRequest(::google::protobuf::Arena* arena, const mgmtRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kRequestBodyFieldNumber = 3,
    kMgmtIdFieldNumber = 5,
    kPwFieldNumber = 6,
    kMsgTypeFieldNumber = 2,
    kRequestNoFieldNumber = 4,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // optional string requestBody = 3;
  bool has_requestbody() const;
  void clear_requestbody() ;
  const std::string& requestbody() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_requestbody(Arg_&& arg, Args_... args);
  std::string* mutable_requestbody();
  PROTOBUF_NODISCARD std::string* release_requestbody();
  void set_allocated_requestbody(std::string* value);

  private:
  const std::string& _internal_requestbody() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_requestbody(
      const std::string& value);
  std::string* _internal_mutable_requestbody();

  public:
  // string mgmtId = 5;
  void clear_mgmtid() ;
  const std::string& mgmtid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mgmtid(Arg_&& arg, Args_... args);
  std::string* mutable_mgmtid();
  PROTOBUF_NODISCARD std::string* release_mgmtid();
  void set_allocated_mgmtid(std::string* value);

  private:
  const std::string& _internal_mgmtid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mgmtid(
      const std::string& value);
  std::string* _internal_mutable_mgmtid();

  public:
  // string pw = 6;
  void clear_pw() ;
  const std::string& pw() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pw(Arg_&& arg, Args_... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* value);

  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(
      const std::string& value);
  std::string* _internal_mutable_pw();

  public:
  // .autopapi.srvRequestType msgType = 2;
  void clear_msgtype() ;
  ::autopapi::srvRequestType msgtype() const;
  void set_msgtype(::autopapi::srvRequestType value);

  private:
  ::autopapi::srvRequestType _internal_msgtype() const;
  void _internal_set_msgtype(::autopapi::srvRequestType value);

  public:
  // optional uint32 requestNo = 4;
  bool has_requestno() const;
  void clear_requestno() ;
  ::uint32_t requestno() const;
  void set_requestno(::uint32_t value);

  private:
  ::uint32_t _internal_requestno() const;
  void _internal_set_requestno(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:autopapi.mgmtRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr requestbody_;
    ::google::protobuf::internal::ArenaStringPtr mgmtid_;
    ::google::protobuf::internal::ArenaStringPtr pw_;
    int msgtype_;
    ::uint32_t requestno_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class mgmtMsmtSettings final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.mgmtMsmtSettings) */ {
 public:
  inline mgmtMsmtSettings() : mgmtMsmtSettings(nullptr) {}
  ~mgmtMsmtSettings() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR mgmtMsmtSettings(::google::protobuf::internal::ConstantInitialized);

  inline mgmtMsmtSettings(const mgmtMsmtSettings& from)
      : mgmtMsmtSettings(nullptr, from) {}
  mgmtMsmtSettings(mgmtMsmtSettings&& from) noexcept
    : mgmtMsmtSettings() {
    *this = ::std::move(from);
  }

  inline mgmtMsmtSettings& operator=(const mgmtMsmtSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline mgmtMsmtSettings& operator=(mgmtMsmtSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mgmtMsmtSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const mgmtMsmtSettings* internal_default_instance() {
    return reinterpret_cast<const mgmtMsmtSettings*>(
               &_mgmtMsmtSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(mgmtMsmtSettings& a, mgmtMsmtSettings& b) {
    a.Swap(&b);
  }
  inline void Swap(mgmtMsmtSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mgmtMsmtSettings* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mgmtMsmtSettings* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mgmtMsmtSettings>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const mgmtMsmtSettings& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const mgmtMsmtSettings& from) {
    mgmtMsmtSettings::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(mgmtMsmtSettings* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.mgmtMsmtSettings";
  }
  protected:
  explicit mgmtMsmtSettings(::google::protobuf::Arena* arena);
  mgmtMsmtSettings(::google::protobuf::Arena* arena, const mgmtMsmtSettings& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kPpDeviceFieldNumber = 3,
    kPpSamplingIntervalFieldNumber = 4,
    kMgmtIdFieldNumber = 6,
    kPwFieldNumber = 7,
    kUploadIntervalMinFieldNumber = 5,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // string ppDevice = 3;
  void clear_ppdevice() ;
  const std::string& ppdevice() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ppdevice(Arg_&& arg, Args_... args);
  std::string* mutable_ppdevice();
  PROTOBUF_NODISCARD std::string* release_ppdevice();
  void set_allocated_ppdevice(std::string* value);

  private:
  const std::string& _internal_ppdevice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ppdevice(
      const std::string& value);
  std::string* _internal_mutable_ppdevice();

  public:
  // string ppSamplingInterval = 4;
  void clear_ppsamplinginterval() ;
  const std::string& ppsamplinginterval() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ppsamplinginterval(Arg_&& arg, Args_... args);
  std::string* mutable_ppsamplinginterval();
  PROTOBUF_NODISCARD std::string* release_ppsamplinginterval();
  void set_allocated_ppsamplinginterval(std::string* value);

  private:
  const std::string& _internal_ppsamplinginterval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ppsamplinginterval(
      const std::string& value);
  std::string* _internal_mutable_ppsamplinginterval();

  public:
  // string mgmtId = 6;
  void clear_mgmtid() ;
  const std::string& mgmtid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mgmtid(Arg_&& arg, Args_... args);
  std::string* mutable_mgmtid();
  PROTOBUF_NODISCARD std::string* release_mgmtid();
  void set_allocated_mgmtid(std::string* value);

  private:
  const std::string& _internal_mgmtid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mgmtid(
      const std::string& value);
  std::string* _internal_mutable_mgmtid();

  public:
  // string pw = 7;
  void clear_pw() ;
  const std::string& pw() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pw(Arg_&& arg, Args_... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* value);

  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(
      const std::string& value);
  std::string* _internal_mutable_pw();

  public:
  // uint32 uploadIntervalMin = 5;
  void clear_uploadintervalmin() ;
  ::uint32_t uploadintervalmin() const;
  void set_uploadintervalmin(::uint32_t value);

  private:
  ::uint32_t _internal_uploadintervalmin() const;
  void _internal_set_uploadintervalmin(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:autopapi.mgmtMsmtSettings)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      77, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr ppdevice_;
    ::google::protobuf::internal::ArenaStringPtr ppsamplinginterval_;
    ::google::protobuf::internal::ArenaStringPtr mgmtid_;
    ::google::protobuf::internal::ArenaStringPtr pw_;
    ::uint32_t uploadintervalmin_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class mgmtAuth final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.mgmtAuth) */ {
 public:
  inline mgmtAuth() : mgmtAuth(nullptr) {}
  ~mgmtAuth() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR mgmtAuth(::google::protobuf::internal::ConstantInitialized);

  inline mgmtAuth(const mgmtAuth& from)
      : mgmtAuth(nullptr, from) {}
  mgmtAuth(mgmtAuth&& from) noexcept
    : mgmtAuth() {
    *this = ::std::move(from);
  }

  inline mgmtAuth& operator=(const mgmtAuth& from) {
    CopyFrom(from);
    return *this;
  }
  inline mgmtAuth& operator=(mgmtAuth&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mgmtAuth& default_instance() {
    return *internal_default_instance();
  }
  static inline const mgmtAuth* internal_default_instance() {
    return reinterpret_cast<const mgmtAuth*>(
               &_mgmtAuth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(mgmtAuth& a, mgmtAuth& b) {
    a.Swap(&b);
  }
  inline void Swap(mgmtAuth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mgmtAuth* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mgmtAuth* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mgmtAuth>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const mgmtAuth& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const mgmtAuth& from) {
    mgmtAuth::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(mgmtAuth* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.mgmtAuth";
  }
  protected:
  explicit mgmtAuth(::google::protobuf::Arena* arena);
  mgmtAuth(::google::protobuf::Arena* arena, const mgmtAuth& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMgmtIdFieldNumber = 1,
    kPwFieldNumber = 2,
  };
  // string mgmtId = 1;
  void clear_mgmtid() ;
  const std::string& mgmtid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mgmtid(Arg_&& arg, Args_... args);
  std::string* mutable_mgmtid();
  PROTOBUF_NODISCARD std::string* release_mgmtid();
  void set_allocated_mgmtid(std::string* value);

  private:
  const std::string& _internal_mgmtid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mgmtid(
      const std::string& value);
  std::string* _internal_mutable_mgmtid();

  public:
  // string pw = 2;
  void clear_pw() ;
  const std::string& pw() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pw(Arg_&& arg, Args_... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* value);

  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(
      const std::string& value);
  std::string* _internal_mutable_pw();

  public:
  // @@protoc_insertion_point(class_scope:autopapi.mgmtAuth)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr mgmtid_;
    ::google::protobuf::internal::ArenaStringPtr pw_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class cmMCode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.cmMCode) */ {
 public:
  inline cmMCode() : cmMCode(nullptr) {}
  ~cmMCode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR cmMCode(::google::protobuf::internal::ConstantInitialized);

  inline cmMCode(const cmMCode& from)
      : cmMCode(nullptr, from) {}
  cmMCode(cmMCode&& from) noexcept
    : cmMCode() {
    *this = ::std::move(from);
  }

  inline cmMCode& operator=(const cmMCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline cmMCode& operator=(cmMCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const cmMCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const cmMCode* internal_default_instance() {
    return reinterpret_cast<const cmMCode*>(
               &_cmMCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(cmMCode& a, cmMCode& b) {
    a.Swap(&b);
  }
  inline void Swap(cmMCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(cmMCode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  cmMCode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<cmMCode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const cmMCode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const cmMCode& from) {
    cmMCode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(cmMCode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.cmMCode";
  }
  protected:
  explicit cmMCode(::google::protobuf::Arena* arena);
  cmMCode(::google::protobuf::Arena* arena, const cmMCode& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kMsgFieldNumber = 3,
    kStatusCodeFieldNumber = 2,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // string msg = 3;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* value);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // uint32 statusCode = 2;
  void clear_statuscode() ;
  ::uint32_t statuscode() const;
  void set_statuscode(::uint32_t value);

  private:
  ::uint32_t _internal_statuscode() const;
  void _internal_set_statuscode(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:autopapi.cmMCode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr msg_;
    ::uint32_t statuscode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class clientUid final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.clientUid) */ {
 public:
  inline clientUid() : clientUid(nullptr) {}
  ~clientUid() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR clientUid(::google::protobuf::internal::ConstantInitialized);

  inline clientUid(const clientUid& from)
      : clientUid(nullptr, from) {}
  clientUid(clientUid&& from) noexcept
    : clientUid() {
    *this = ::std::move(from);
  }

  inline clientUid& operator=(const clientUid& from) {
    CopyFrom(from);
    return *this;
  }
  inline clientUid& operator=(clientUid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const clientUid& default_instance() {
    return *internal_default_instance();
  }
  static inline const clientUid* internal_default_instance() {
    return reinterpret_cast<const clientUid*>(
               &_clientUid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(clientUid& a, clientUid& b) {
    a.Swap(&b);
  }
  inline void Swap(clientUid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(clientUid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  clientUid* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<clientUid>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const clientUid& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const clientUid& from) {
    clientUid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(clientUid* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.clientUid";
  }
  protected:
  explicit clientUid(::google::protobuf::Arena* arena);
  clientUid(::google::protobuf::Arena* arena, const clientUid& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUidFieldNumber = 1,
  };
  // string uid = 1;
  void clear_uid() ;
  const std::string& uid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uid(Arg_&& arg, Args_... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* value);

  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(
      const std::string& value);
  std::string* _internal_mutable_uid();

  public:
  // @@protoc_insertion_point(class_scope:autopapi.clientUid)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr uid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class clientResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.clientResponse) */ {
 public:
  inline clientResponse() : clientResponse(nullptr) {}
  ~clientResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR clientResponse(::google::protobuf::internal::ConstantInitialized);

  inline clientResponse(const clientResponse& from)
      : clientResponse(nullptr, from) {}
  clientResponse(clientResponse&& from) noexcept
    : clientResponse() {
    *this = ::std::move(from);
  }

  inline clientResponse& operator=(const clientResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline clientResponse& operator=(clientResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const clientResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const clientResponse* internal_default_instance() {
    return reinterpret_cast<const clientResponse*>(
               &_clientResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(clientResponse& a, clientResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(clientResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(clientResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  clientResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<clientResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const clientResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const clientResponse& from) {
    clientResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(clientResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.clientResponse";
  }
  protected:
  explicit clientResponse(::google::protobuf::Arena* arena);
  clientResponse(::google::protobuf::Arena* arena, const clientResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kMsgFieldNumber = 4,
    kStatusCodeFieldNumber = 2,
    kMsgTypeFieldNumber = 3,
    kRequestNoFieldNumber = 5,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // optional string msg = 4;
  bool has_msg() const;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* value);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // uint32 statusCode = 2;
  void clear_statuscode() ;
  ::uint32_t statuscode() const;
  void set_statuscode(::uint32_t value);

  private:
  ::uint32_t _internal_statuscode() const;
  void _internal_set_statuscode(::uint32_t value);

  public:
  // .autopapi.clientResponseType msgType = 3;
  void clear_msgtype() ;
  ::autopapi::clientResponseType msgtype() const;
  void set_msgtype(::autopapi::clientResponseType value);

  private:
  ::autopapi::clientResponseType _internal_msgtype() const;
  void _internal_set_msgtype(::autopapi::clientResponseType value);

  public:
  // uint32 requestNo = 5;
  void clear_requestno() ;
  ::uint32_t requestno() const;
  void set_requestno(::uint32_t value);

  private:
  ::uint32_t _internal_requestno() const;
  void _internal_set_requestno(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:autopapi.clientResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr msg_;
    ::uint32_t statuscode_;
    int msgtype_;
    ::uint32_t requestno_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class authClientUid final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.authClientUid) */ {
 public:
  inline authClientUid() : authClientUid(nullptr) {}
  ~authClientUid() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR authClientUid(::google::protobuf::internal::ConstantInitialized);

  inline authClientUid(const authClientUid& from)
      : authClientUid(nullptr, from) {}
  authClientUid(authClientUid&& from) noexcept
    : authClientUid() {
    *this = ::std::move(from);
  }

  inline authClientUid& operator=(const authClientUid& from) {
    CopyFrom(from);
    return *this;
  }
  inline authClientUid& operator=(authClientUid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const authClientUid& default_instance() {
    return *internal_default_instance();
  }
  static inline const authClientUid* internal_default_instance() {
    return reinterpret_cast<const authClientUid*>(
               &_authClientUid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(authClientUid& a, authClientUid& b) {
    a.Swap(&b);
  }
  inline void Swap(authClientUid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(authClientUid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  authClientUid* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<authClientUid>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const authClientUid& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const authClientUid& from) {
    authClientUid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(authClientUid* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.authClientUid";
  }
  protected:
  explicit authClientUid(::google::protobuf::Arena* arena);
  authClientUid(::google::protobuf::Arena* arena, const authClientUid& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kMgmtIdFieldNumber = 2,
    kPwFieldNumber = 3,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // string mgmtId = 2;
  void clear_mgmtid() ;
  const std::string& mgmtid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mgmtid(Arg_&& arg, Args_... args);
  std::string* mutable_mgmtid();
  PROTOBUF_NODISCARD std::string* release_mgmtid();
  void set_allocated_mgmtid(std::string* value);

  private:
  const std::string& _internal_mgmtid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mgmtid(
      const std::string& value);
  std::string* _internal_mutable_mgmtid();

  public:
  // string pw = 3;
  void clear_pw() ;
  const std::string& pw() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pw(Arg_&& arg, Args_... args);
  std::string* mutable_pw();
  PROTOBUF_NODISCARD std::string* release_pw();
  void set_allocated_pw(std::string* value);

  private:
  const std::string& _internal_pw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pw(
      const std::string& value);
  std::string* _internal_mutable_pw();

  public:
  // @@protoc_insertion_point(class_scope:autopapi.authClientUid)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr mgmtid_;
    ::google::protobuf::internal::ArenaStringPtr pw_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};// -------------------------------------------------------------------

class msmtSample final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:autopapi.msmtSample) */ {
 public:
  inline msmtSample() : msmtSample(nullptr) {}
  ~msmtSample() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR msmtSample(::google::protobuf::internal::ConstantInitialized);

  inline msmtSample(const msmtSample& from)
      : msmtSample(nullptr, from) {}
  msmtSample(msmtSample&& from) noexcept
    : msmtSample() {
    *this = ::std::move(from);
  }

  inline msmtSample& operator=(const msmtSample& from) {
    CopyFrom(from);
    return *this;
  }
  inline msmtSample& operator=(msmtSample&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const msmtSample& default_instance() {
    return *internal_default_instance();
  }
  static inline const msmtSample* internal_default_instance() {
    return reinterpret_cast<const msmtSample*>(
               &_msmtSample_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(msmtSample& a, msmtSample& b) {
    a.Swap(&b);
  }
  inline void Swap(msmtSample* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(msmtSample* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  msmtSample* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<msmtSample>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const msmtSample& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const msmtSample& from) {
    msmtSample::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(msmtSample* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "autopapi.msmtSample";
  }
  protected:
  explicit msmtSample(::google::protobuf::Arena* arena);
  msmtSample(::google::protobuf::Arena* arena, const msmtSample& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientUidFieldNumber = 1,
    kMsmtIdFieldNumber = 2,
    kMsmtTimeFieldNumber = 3,
    kSampleIdFieldNumber = 5,
    kMsmtContentFieldNumber = 4,
  };
  // string clientUid = 1;
  void clear_clientuid() ;
  const std::string& clientuid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_clientuid(Arg_&& arg, Args_... args);
  std::string* mutable_clientuid();
  PROTOBUF_NODISCARD std::string* release_clientuid();
  void set_allocated_clientuid(std::string* value);

  private:
  const std::string& _internal_clientuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientuid(
      const std::string& value);
  std::string* _internal_mutable_clientuid();

  public:
  // string msmtId = 2;
  void clear_msmtid() ;
  const std::string& msmtid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msmtid(Arg_&& arg, Args_... args);
  std::string* mutable_msmtid();
  PROTOBUF_NODISCARD std::string* release_msmtid();
  void set_allocated_msmtid(std::string* value);

  private:
  const std::string& _internal_msmtid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msmtid(
      const std::string& value);
  std::string* _internal_mutable_msmtid();

  public:
  // .google.protobuf.Timestamp msmtTime = 3;
  bool has_msmttime() const;
  void clear_msmttime() ;
  const ::google::protobuf::Timestamp& msmttime() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_msmttime();
  ::google::protobuf::Timestamp* mutable_msmttime();
  void set_allocated_msmttime(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_msmttime(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_msmttime();

  private:
  const ::google::protobuf::Timestamp& _internal_msmttime() const;
  ::google::protobuf::Timestamp* _internal_mutable_msmttime();

  public:
  // uint64 sampleId = 5;
  void clear_sampleid() ;
  ::uint64_t sampleid() const;
  void set_sampleid(::uint64_t value);

  private:
  ::uint64_t _internal_sampleid() const;
  void _internal_set_sampleid(::uint64_t value);

  public:
  // uint32 msmtContent = 4;
  void clear_msmtcontent() ;
  ::uint32_t msmtcontent() const;
  void set_msmtcontent(::uint32_t value);

  private:
  ::uint32_t _internal_msmtcontent() const;
  void _internal_set_msmtcontent(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:autopapi.msmtSample)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      43, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr clientuid_;
    ::google::protobuf::internal::ArenaStringPtr msmtid_;
    ::google::protobuf::Timestamp* msmttime_;
    ::uint64_t sampleid_;
    ::uint32_t msmtcontent_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// nothing

// -------------------------------------------------------------------

// cmMCode

// string clientUid = 1;
inline void cmMCode::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& cmMCode::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.cmMCode.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void cmMCode::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.cmMCode.clientUid)
}
inline std::string* cmMCode::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.cmMCode.clientUid)
  return _s;
}
inline const std::string& cmMCode::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void cmMCode::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* cmMCode::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* cmMCode::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.cmMCode.clientUid)
  return _impl_.clientuid_.Release();
}
inline void cmMCode::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.cmMCode.clientUid)
}

// uint32 statusCode = 2;
inline void cmMCode::clear_statuscode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statuscode_ = 0u;
}
inline ::uint32_t cmMCode::statuscode() const {
  // @@protoc_insertion_point(field_get:autopapi.cmMCode.statusCode)
  return _internal_statuscode();
}
inline void cmMCode::set_statuscode(::uint32_t value) {
  _internal_set_statuscode(value);
  // @@protoc_insertion_point(field_set:autopapi.cmMCode.statusCode)
}
inline ::uint32_t cmMCode::_internal_statuscode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.statuscode_;
}
inline void cmMCode::_internal_set_statuscode(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.statuscode_ = value;
}

// string msg = 3;
inline void cmMCode::clear_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& cmMCode::msg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.cmMCode.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void cmMCode::set_msg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.cmMCode.msg)
}
inline std::string* cmMCode::mutable_msg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:autopapi.cmMCode.msg)
  return _s;
}
inline const std::string& cmMCode::_internal_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msg_.Get();
}
inline void cmMCode::_internal_set_msg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_.Set(value, GetArena());
}
inline std::string* cmMCode::_internal_mutable_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.msg_.Mutable( GetArena());
}
inline std::string* cmMCode::release_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.cmMCode.msg)
  return _impl_.msg_.Release();
}
inline void cmMCode::set_allocated_msg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.cmMCode.msg)
}

// -------------------------------------------------------------------

// srvRequest

// string clientUid = 1;
inline void srvRequest::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& srvRequest::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.srvRequest.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void srvRequest::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.srvRequest.clientUid)
}
inline std::string* srvRequest::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.srvRequest.clientUid)
  return _s;
}
inline const std::string& srvRequest::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void srvRequest::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* srvRequest::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* srvRequest::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.srvRequest.clientUid)
  return _impl_.clientuid_.Release();
}
inline void srvRequest::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.srvRequest.clientUid)
}

// .autopapi.srvRequestType msgType = 2;
inline void srvRequest::clear_msgtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgtype_ = 0;
}
inline ::autopapi::srvRequestType srvRequest::msgtype() const {
  // @@protoc_insertion_point(field_get:autopapi.srvRequest.msgType)
  return _internal_msgtype();
}
inline void srvRequest::set_msgtype(::autopapi::srvRequestType value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:autopapi.srvRequest.msgType)
}
inline ::autopapi::srvRequestType srvRequest::_internal_msgtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::autopapi::srvRequestType>(_impl_.msgtype_);
}
inline void srvRequest::_internal_set_msgtype(::autopapi::srvRequestType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msgtype_ = value;
}

// optional string requestBody = 3;
inline bool srvRequest::has_requestbody() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void srvRequest::clear_requestbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestbody_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& srvRequest::requestbody() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.srvRequest.requestBody)
  return _internal_requestbody();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void srvRequest::set_requestbody(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.requestbody_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.srvRequest.requestBody)
}
inline std::string* srvRequest::mutable_requestbody() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestbody();
  // @@protoc_insertion_point(field_mutable:autopapi.srvRequest.requestBody)
  return _s;
}
inline const std::string& srvRequest::_internal_requestbody() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestbody_.Get();
}
inline void srvRequest::_internal_set_requestbody(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.requestbody_.Set(value, GetArena());
}
inline std::string* srvRequest::_internal_mutable_requestbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.requestbody_.Mutable( GetArena());
}
inline std::string* srvRequest::release_requestbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.srvRequest.requestBody)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.requestbody_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.requestbody_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void srvRequest::set_allocated_requestbody(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.requestbody_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestbody_.IsDefault()) {
          _impl_.requestbody_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.srvRequest.requestBody)
}

// uint32 requestNo = 4;
inline void srvRequest::clear_requestno() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestno_ = 0u;
}
inline ::uint32_t srvRequest::requestno() const {
  // @@protoc_insertion_point(field_get:autopapi.srvRequest.requestNo)
  return _internal_requestno();
}
inline void srvRequest::set_requestno(::uint32_t value) {
  _internal_set_requestno(value);
  // @@protoc_insertion_point(field_set:autopapi.srvRequest.requestNo)
}
inline ::uint32_t srvRequest::_internal_requestno() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestno_;
}
inline void srvRequest::_internal_set_requestno(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestno_ = value;
}

// -------------------------------------------------------------------

// clientResponse

// string clientUid = 1;
inline void clientResponse::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& clientResponse::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.clientResponse.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void clientResponse::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.clientResponse.clientUid)
}
inline std::string* clientResponse::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.clientResponse.clientUid)
  return _s;
}
inline const std::string& clientResponse::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void clientResponse::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* clientResponse::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* clientResponse::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.clientResponse.clientUid)
  return _impl_.clientuid_.Release();
}
inline void clientResponse::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.clientResponse.clientUid)
}

// uint32 statusCode = 2;
inline void clientResponse::clear_statuscode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statuscode_ = 0u;
}
inline ::uint32_t clientResponse::statuscode() const {
  // @@protoc_insertion_point(field_get:autopapi.clientResponse.statusCode)
  return _internal_statuscode();
}
inline void clientResponse::set_statuscode(::uint32_t value) {
  _internal_set_statuscode(value);
  // @@protoc_insertion_point(field_set:autopapi.clientResponse.statusCode)
}
inline ::uint32_t clientResponse::_internal_statuscode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.statuscode_;
}
inline void clientResponse::_internal_set_statuscode(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.statuscode_ = value;
}

// .autopapi.clientResponseType msgType = 3;
inline void clientResponse::clear_msgtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgtype_ = 0;
}
inline ::autopapi::clientResponseType clientResponse::msgtype() const {
  // @@protoc_insertion_point(field_get:autopapi.clientResponse.msgType)
  return _internal_msgtype();
}
inline void clientResponse::set_msgtype(::autopapi::clientResponseType value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:autopapi.clientResponse.msgType)
}
inline ::autopapi::clientResponseType clientResponse::_internal_msgtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::autopapi::clientResponseType>(_impl_.msgtype_);
}
inline void clientResponse::_internal_set_msgtype(::autopapi::clientResponseType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msgtype_ = value;
}

// optional string msg = 4;
inline bool clientResponse::has_msg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void clientResponse::clear_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& clientResponse::msg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.clientResponse.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void clientResponse::set_msg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.clientResponse.msg)
}
inline std::string* clientResponse::mutable_msg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:autopapi.clientResponse.msg)
  return _s;
}
inline const std::string& clientResponse::_internal_msg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msg_.Get();
}
inline void clientResponse::_internal_set_msg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.msg_.Set(value, GetArena());
}
inline std::string* clientResponse::_internal_mutable_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.msg_.Mutable( GetArena());
}
inline std::string* clientResponse::release_msg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.clientResponse.msg)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.msg_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.msg_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void clientResponse::set_allocated_msg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.msg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.clientResponse.msg)
}

// uint32 requestNo = 5;
inline void clientResponse::clear_requestno() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestno_ = 0u;
}
inline ::uint32_t clientResponse::requestno() const {
  // @@protoc_insertion_point(field_get:autopapi.clientResponse.requestNo)
  return _internal_requestno();
}
inline void clientResponse::set_requestno(::uint32_t value) {
  _internal_set_requestno(value);
  // @@protoc_insertion_point(field_set:autopapi.clientResponse.requestNo)
}
inline ::uint32_t clientResponse::_internal_requestno() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestno_;
}
inline void clientResponse::_internal_set_requestno(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.requestno_ = value;
}

// -------------------------------------------------------------------

// clientUid

// string uid = 1;
inline void clientUid::clear_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.ClearToEmpty();
}
inline const std::string& clientUid::uid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.clientUid.uid)
  return _internal_uid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void clientUid::set_uid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.clientUid.uid)
}
inline std::string* clientUid::mutable_uid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:autopapi.clientUid.uid)
  return _s;
}
inline const std::string& clientUid::_internal_uid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uid_.Get();
}
inline void clientUid::_internal_set_uid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uid_.Set(value, GetArena());
}
inline std::string* clientUid::_internal_mutable_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.uid_.Mutable( GetArena());
}
inline std::string* clientUid::release_uid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.clientUid.uid)
  return _impl_.uid_.Release();
}
inline void clientUid::set_allocated_uid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uid_.IsDefault()) {
          _impl_.uid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.clientUid.uid)
}

// -------------------------------------------------------------------

// authClientUid

// string clientUid = 1;
inline void authClientUid::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& authClientUid::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.authClientUid.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void authClientUid::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.authClientUid.clientUid)
}
inline std::string* authClientUid::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.authClientUid.clientUid)
  return _s;
}
inline const std::string& authClientUid::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void authClientUid::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* authClientUid::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* authClientUid::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.authClientUid.clientUid)
  return _impl_.clientuid_.Release();
}
inline void authClientUid::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.authClientUid.clientUid)
}

// string mgmtId = 2;
inline void authClientUid::clear_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgmtid_.ClearToEmpty();
}
inline const std::string& authClientUid::mgmtid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.authClientUid.mgmtId)
  return _internal_mgmtid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void authClientUid::set_mgmtid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mgmtid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.authClientUid.mgmtId)
}
inline std::string* authClientUid::mutable_mgmtid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mgmtid();
  // @@protoc_insertion_point(field_mutable:autopapi.authClientUid.mgmtId)
  return _s;
}
inline const std::string& authClientUid::_internal_mgmtid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mgmtid_.Get();
}
inline void authClientUid::_internal_set_mgmtid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mgmtid_.Set(value, GetArena());
}
inline std::string* authClientUid::_internal_mutable_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mgmtid_.Mutable( GetArena());
}
inline std::string* authClientUid::release_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.authClientUid.mgmtId)
  return _impl_.mgmtid_.Release();
}
inline void authClientUid::set_allocated_mgmtid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgmtid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mgmtid_.IsDefault()) {
          _impl_.mgmtid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.authClientUid.mgmtId)
}

// string pw = 3;
inline void authClientUid::clear_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pw_.ClearToEmpty();
}
inline const std::string& authClientUid::pw() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.authClientUid.pw)
  return _internal_pw();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void authClientUid::set_pw(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pw_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.authClientUid.pw)
}
inline std::string* authClientUid::mutable_pw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:autopapi.authClientUid.pw)
  return _s;
}
inline const std::string& authClientUid::_internal_pw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pw_.Get();
}
inline void authClientUid::_internal_set_pw(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pw_.Set(value, GetArena());
}
inline std::string* authClientUid::_internal_mutable_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.pw_.Mutable( GetArena());
}
inline std::string* authClientUid::release_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.authClientUid.pw)
  return _impl_.pw_.Release();
}
inline void authClientUid::set_allocated_pw(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pw_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pw_.IsDefault()) {
          _impl_.pw_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.authClientUid.pw)
}

// -------------------------------------------------------------------

// registrationStatus

// string clientUid = 1;
inline void registrationStatus::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& registrationStatus::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.registrationStatus.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void registrationStatus::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.registrationStatus.clientUid)
}
inline std::string* registrationStatus::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.registrationStatus.clientUid)
  return _s;
}
inline const std::string& registrationStatus::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void registrationStatus::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* registrationStatus::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* registrationStatus::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.registrationStatus.clientUid)
  return _impl_.clientuid_.Release();
}
inline void registrationStatus::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.registrationStatus.clientUid)
}

// string regStatus = 2;
inline void registrationStatus::clear_regstatus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.regstatus_.ClearToEmpty();
}
inline const std::string& registrationStatus::regstatus() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.registrationStatus.regStatus)
  return _internal_regstatus();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void registrationStatus::set_regstatus(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.regstatus_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.registrationStatus.regStatus)
}
inline std::string* registrationStatus::mutable_regstatus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_regstatus();
  // @@protoc_insertion_point(field_mutable:autopapi.registrationStatus.regStatus)
  return _s;
}
inline const std::string& registrationStatus::_internal_regstatus() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.regstatus_.Get();
}
inline void registrationStatus::_internal_set_regstatus(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.regstatus_.Set(value, GetArena());
}
inline std::string* registrationStatus::_internal_mutable_regstatus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.regstatus_.Mutable( GetArena());
}
inline std::string* registrationStatus::release_regstatus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.registrationStatus.regStatus)
  return _impl_.regstatus_.Release();
}
inline void registrationStatus::set_allocated_regstatus(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.regstatus_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.regstatus_.IsDefault()) {
          _impl_.regstatus_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.registrationStatus.regStatus)
}

// -------------------------------------------------------------------

// msmtSettings

// string clientUid = 1;
inline void msmtSettings::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& msmtSettings::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.msmtSettings.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msmtSettings::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.msmtSettings.clientUid)
}
inline std::string* msmtSettings::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.msmtSettings.clientUid)
  return _s;
}
inline const std::string& msmtSettings::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void msmtSettings::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* msmtSettings::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* msmtSettings::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.msmtSettings.clientUid)
  return _impl_.clientuid_.Release();
}
inline void msmtSettings::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.msmtSettings.clientUid)
}

// string ppDevice = 3;
inline void msmtSettings::clear_ppdevice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ppdevice_.ClearToEmpty();
}
inline const std::string& msmtSettings::ppdevice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.msmtSettings.ppDevice)
  return _internal_ppdevice();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msmtSettings::set_ppdevice(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ppdevice_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.msmtSettings.ppDevice)
}
inline std::string* msmtSettings::mutable_ppdevice() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ppdevice();
  // @@protoc_insertion_point(field_mutable:autopapi.msmtSettings.ppDevice)
  return _s;
}
inline const std::string& msmtSettings::_internal_ppdevice() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ppdevice_.Get();
}
inline void msmtSettings::_internal_set_ppdevice(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ppdevice_.Set(value, GetArena());
}
inline std::string* msmtSettings::_internal_mutable_ppdevice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ppdevice_.Mutable( GetArena());
}
inline std::string* msmtSettings::release_ppdevice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.msmtSettings.ppDevice)
  return _impl_.ppdevice_.Release();
}
inline void msmtSettings::set_allocated_ppdevice(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ppdevice_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ppdevice_.IsDefault()) {
          _impl_.ppdevice_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.msmtSettings.ppDevice)
}

// string ppSamplingInterval = 4;
inline void msmtSettings::clear_ppsamplinginterval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ppsamplinginterval_.ClearToEmpty();
}
inline const std::string& msmtSettings::ppsamplinginterval() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.msmtSettings.ppSamplingInterval)
  return _internal_ppsamplinginterval();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msmtSettings::set_ppsamplinginterval(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ppsamplinginterval_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.msmtSettings.ppSamplingInterval)
}
inline std::string* msmtSettings::mutable_ppsamplinginterval() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ppsamplinginterval();
  // @@protoc_insertion_point(field_mutable:autopapi.msmtSettings.ppSamplingInterval)
  return _s;
}
inline const std::string& msmtSettings::_internal_ppsamplinginterval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ppsamplinginterval_.Get();
}
inline void msmtSettings::_internal_set_ppsamplinginterval(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ppsamplinginterval_.Set(value, GetArena());
}
inline std::string* msmtSettings::_internal_mutable_ppsamplinginterval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ppsamplinginterval_.Mutable( GetArena());
}
inline std::string* msmtSettings::release_ppsamplinginterval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.msmtSettings.ppSamplingInterval)
  return _impl_.ppsamplinginterval_.Release();
}
inline void msmtSettings::set_allocated_ppsamplinginterval(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ppsamplinginterval_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ppsamplinginterval_.IsDefault()) {
          _impl_.ppsamplinginterval_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.msmtSettings.ppSamplingInterval)
}

// uint32 uploadIntervalMin = 5;
inline void msmtSettings::clear_uploadintervalmin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uploadintervalmin_ = 0u;
}
inline ::uint32_t msmtSettings::uploadintervalmin() const {
  // @@protoc_insertion_point(field_get:autopapi.msmtSettings.uploadIntervalMin)
  return _internal_uploadintervalmin();
}
inline void msmtSettings::set_uploadintervalmin(::uint32_t value) {
  _internal_set_uploadintervalmin(value);
  // @@protoc_insertion_point(field_set:autopapi.msmtSettings.uploadIntervalMin)
}
inline ::uint32_t msmtSettings::_internal_uploadintervalmin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uploadintervalmin_;
}
inline void msmtSettings::_internal_set_uploadintervalmin(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uploadintervalmin_ = value;
}

// -------------------------------------------------------------------

// msmtSample

// string clientUid = 1;
inline void msmtSample::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& msmtSample::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.msmtSample.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msmtSample::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.msmtSample.clientUid)
}
inline std::string* msmtSample::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.msmtSample.clientUid)
  return _s;
}
inline const std::string& msmtSample::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void msmtSample::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* msmtSample::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* msmtSample::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.msmtSample.clientUid)
  return _impl_.clientuid_.Release();
}
inline void msmtSample::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.msmtSample.clientUid)
}

// string msmtId = 2;
inline void msmtSample::clear_msmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msmtid_.ClearToEmpty();
}
inline const std::string& msmtSample::msmtid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.msmtSample.msmtId)
  return _internal_msmtid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msmtSample::set_msmtid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msmtid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.msmtSample.msmtId)
}
inline std::string* msmtSample::mutable_msmtid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_msmtid();
  // @@protoc_insertion_point(field_mutable:autopapi.msmtSample.msmtId)
  return _s;
}
inline const std::string& msmtSample::_internal_msmtid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msmtid_.Get();
}
inline void msmtSample::_internal_set_msmtid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msmtid_.Set(value, GetArena());
}
inline std::string* msmtSample::_internal_mutable_msmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.msmtid_.Mutable( GetArena());
}
inline std::string* msmtSample::release_msmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.msmtSample.msmtId)
  return _impl_.msmtid_.Release();
}
inline void msmtSample::set_allocated_msmtid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msmtid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msmtid_.IsDefault()) {
          _impl_.msmtid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.msmtSample.msmtId)
}

// .google.protobuf.Timestamp msmtTime = 3;
inline bool msmtSample::has_msmttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.msmttime_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& msmtSample::_internal_msmttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.msmttime_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& msmtSample::msmttime() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.msmtSample.msmtTime)
  return _internal_msmttime();
}
inline void msmtSample::unsafe_arena_set_allocated_msmttime(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.msmttime_);
  }
  _impl_.msmttime_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:autopapi.msmtSample.msmtTime)
}
inline ::google::protobuf::Timestamp* msmtSample::release_msmttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.msmttime_;
  _impl_.msmttime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* msmtSample::unsafe_arena_release_msmttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.msmtSample.msmtTime)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.msmttime_;
  _impl_.msmttime_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* msmtSample::_internal_mutable_msmttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.msmttime_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArena());
    _impl_.msmttime_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.msmttime_;
}
inline ::google::protobuf::Timestamp* msmtSample::mutable_msmttime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_msmttime();
  // @@protoc_insertion_point(field_mutable:autopapi.msmtSample.msmtTime)
  return _msg;
}
inline void msmtSample::set_allocated_msmttime(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.msmttime_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.msmttime_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:autopapi.msmtSample.msmtTime)
}

// uint32 msmtContent = 4;
inline void msmtSample::clear_msmtcontent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msmtcontent_ = 0u;
}
inline ::uint32_t msmtSample::msmtcontent() const {
  // @@protoc_insertion_point(field_get:autopapi.msmtSample.msmtContent)
  return _internal_msmtcontent();
}
inline void msmtSample::set_msmtcontent(::uint32_t value) {
  _internal_set_msmtcontent(value);
  // @@protoc_insertion_point(field_set:autopapi.msmtSample.msmtContent)
}
inline ::uint32_t msmtSample::_internal_msmtcontent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.msmtcontent_;
}
inline void msmtSample::_internal_set_msmtcontent(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msmtcontent_ = value;
}

// uint64 sampleId = 5;
inline void msmtSample::clear_sampleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sampleid_ = ::uint64_t{0u};
}
inline ::uint64_t msmtSample::sampleid() const {
  // @@protoc_insertion_point(field_get:autopapi.msmtSample.sampleId)
  return _internal_sampleid();
}
inline void msmtSample::set_sampleid(::uint64_t value) {
  _internal_set_sampleid(value);
  // @@protoc_insertion_point(field_set:autopapi.msmtSample.sampleId)
}
inline ::uint64_t msmtSample::_internal_sampleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sampleid_;
}
inline void msmtSample::_internal_set_sampleid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sampleid_ = value;
}

// -------------------------------------------------------------------

// sampleAck

// uint64 sampleId = 1;
inline void sampleAck::clear_sampleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sampleid_ = ::uint64_t{0u};
}
inline ::uint64_t sampleAck::sampleid() const {
  // @@protoc_insertion_point(field_get:autopapi.sampleAck.sampleId)
  return _internal_sampleid();
}
inline void sampleAck::set_sampleid(::uint64_t value) {
  _internal_set_sampleid(value);
  // @@protoc_insertion_point(field_set:autopapi.sampleAck.sampleId)
}
inline ::uint64_t sampleAck::_internal_sampleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sampleid_;
}
inline void sampleAck::_internal_set_sampleid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sampleid_ = value;
}

// -------------------------------------------------------------------

// msmtName

// string clientUid = 1;
inline void msmtName::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& msmtName::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.msmtName.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msmtName::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.msmtName.clientUid)
}
inline std::string* msmtName::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.msmtName.clientUid)
  return _s;
}
inline const std::string& msmtName::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void msmtName::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* msmtName::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* msmtName::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.msmtName.clientUid)
  return _impl_.clientuid_.Release();
}
inline void msmtName::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.msmtName.clientUid)
}

// string name = 2;
inline void msmtName::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& msmtName::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.msmtName.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void msmtName::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.msmtName.name)
}
inline std::string* msmtName::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:autopapi.msmtName.name)
  return _s;
}
inline const std::string& msmtName::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void msmtName::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* msmtName::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* msmtName::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.msmtName.name)
  return _impl_.name_.Release();
}
inline void msmtName::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.msmtName.name)
}

// -------------------------------------------------------------------

// mgmtAuth

// string mgmtId = 1;
inline void mgmtAuth::clear_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgmtid_.ClearToEmpty();
}
inline const std::string& mgmtAuth::mgmtid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtAuth.mgmtId)
  return _internal_mgmtid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtAuth::set_mgmtid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mgmtid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtAuth.mgmtId)
}
inline std::string* mgmtAuth::mutable_mgmtid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mgmtid();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtAuth.mgmtId)
  return _s;
}
inline const std::string& mgmtAuth::_internal_mgmtid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mgmtid_.Get();
}
inline void mgmtAuth::_internal_set_mgmtid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mgmtid_.Set(value, GetArena());
}
inline std::string* mgmtAuth::_internal_mutable_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mgmtid_.Mutable( GetArena());
}
inline std::string* mgmtAuth::release_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtAuth.mgmtId)
  return _impl_.mgmtid_.Release();
}
inline void mgmtAuth::set_allocated_mgmtid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgmtid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mgmtid_.IsDefault()) {
          _impl_.mgmtid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtAuth.mgmtId)
}

// string pw = 2;
inline void mgmtAuth::clear_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pw_.ClearToEmpty();
}
inline const std::string& mgmtAuth::pw() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtAuth.pw)
  return _internal_pw();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtAuth::set_pw(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pw_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtAuth.pw)
}
inline std::string* mgmtAuth::mutable_pw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtAuth.pw)
  return _s;
}
inline const std::string& mgmtAuth::_internal_pw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pw_.Get();
}
inline void mgmtAuth::_internal_set_pw(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pw_.Set(value, GetArena());
}
inline std::string* mgmtAuth::_internal_mutable_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.pw_.Mutable( GetArena());
}
inline std::string* mgmtAuth::release_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtAuth.pw)
  return _impl_.pw_.Release();
}
inline void mgmtAuth::set_allocated_pw(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pw_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pw_.IsDefault()) {
          _impl_.pw_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtAuth.pw)
}

// -------------------------------------------------------------------

// mgmtMsmtSettings

// string clientUid = 1;
inline void mgmtMsmtSettings::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& mgmtMsmtSettings::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtMsmtSettings.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtMsmtSettings::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtMsmtSettings.clientUid)
}
inline std::string* mgmtMsmtSettings::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtMsmtSettings.clientUid)
  return _s;
}
inline const std::string& mgmtMsmtSettings::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void mgmtMsmtSettings::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* mgmtMsmtSettings::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* mgmtMsmtSettings::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtMsmtSettings.clientUid)
  return _impl_.clientuid_.Release();
}
inline void mgmtMsmtSettings::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtMsmtSettings.clientUid)
}

// string ppDevice = 3;
inline void mgmtMsmtSettings::clear_ppdevice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ppdevice_.ClearToEmpty();
}
inline const std::string& mgmtMsmtSettings::ppdevice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtMsmtSettings.ppDevice)
  return _internal_ppdevice();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtMsmtSettings::set_ppdevice(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ppdevice_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtMsmtSettings.ppDevice)
}
inline std::string* mgmtMsmtSettings::mutable_ppdevice() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ppdevice();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtMsmtSettings.ppDevice)
  return _s;
}
inline const std::string& mgmtMsmtSettings::_internal_ppdevice() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ppdevice_.Get();
}
inline void mgmtMsmtSettings::_internal_set_ppdevice(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ppdevice_.Set(value, GetArena());
}
inline std::string* mgmtMsmtSettings::_internal_mutable_ppdevice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ppdevice_.Mutable( GetArena());
}
inline std::string* mgmtMsmtSettings::release_ppdevice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtMsmtSettings.ppDevice)
  return _impl_.ppdevice_.Release();
}
inline void mgmtMsmtSettings::set_allocated_ppdevice(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ppdevice_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ppdevice_.IsDefault()) {
          _impl_.ppdevice_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtMsmtSettings.ppDevice)
}

// string ppSamplingInterval = 4;
inline void mgmtMsmtSettings::clear_ppsamplinginterval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ppsamplinginterval_.ClearToEmpty();
}
inline const std::string& mgmtMsmtSettings::ppsamplinginterval() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtMsmtSettings.ppSamplingInterval)
  return _internal_ppsamplinginterval();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtMsmtSettings::set_ppsamplinginterval(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ppsamplinginterval_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtMsmtSettings.ppSamplingInterval)
}
inline std::string* mgmtMsmtSettings::mutable_ppsamplinginterval() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ppsamplinginterval();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtMsmtSettings.ppSamplingInterval)
  return _s;
}
inline const std::string& mgmtMsmtSettings::_internal_ppsamplinginterval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ppsamplinginterval_.Get();
}
inline void mgmtMsmtSettings::_internal_set_ppsamplinginterval(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ppsamplinginterval_.Set(value, GetArena());
}
inline std::string* mgmtMsmtSettings::_internal_mutable_ppsamplinginterval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.ppsamplinginterval_.Mutable( GetArena());
}
inline std::string* mgmtMsmtSettings::release_ppsamplinginterval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtMsmtSettings.ppSamplingInterval)
  return _impl_.ppsamplinginterval_.Release();
}
inline void mgmtMsmtSettings::set_allocated_ppsamplinginterval(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ppsamplinginterval_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ppsamplinginterval_.IsDefault()) {
          _impl_.ppsamplinginterval_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtMsmtSettings.ppSamplingInterval)
}

// uint32 uploadIntervalMin = 5;
inline void mgmtMsmtSettings::clear_uploadintervalmin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uploadintervalmin_ = 0u;
}
inline ::uint32_t mgmtMsmtSettings::uploadintervalmin() const {
  // @@protoc_insertion_point(field_get:autopapi.mgmtMsmtSettings.uploadIntervalMin)
  return _internal_uploadintervalmin();
}
inline void mgmtMsmtSettings::set_uploadintervalmin(::uint32_t value) {
  _internal_set_uploadintervalmin(value);
  // @@protoc_insertion_point(field_set:autopapi.mgmtMsmtSettings.uploadIntervalMin)
}
inline ::uint32_t mgmtMsmtSettings::_internal_uploadintervalmin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uploadintervalmin_;
}
inline void mgmtMsmtSettings::_internal_set_uploadintervalmin(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.uploadintervalmin_ = value;
}

// string mgmtId = 6;
inline void mgmtMsmtSettings::clear_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgmtid_.ClearToEmpty();
}
inline const std::string& mgmtMsmtSettings::mgmtid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtMsmtSettings.mgmtId)
  return _internal_mgmtid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtMsmtSettings::set_mgmtid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mgmtid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtMsmtSettings.mgmtId)
}
inline std::string* mgmtMsmtSettings::mutable_mgmtid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mgmtid();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtMsmtSettings.mgmtId)
  return _s;
}
inline const std::string& mgmtMsmtSettings::_internal_mgmtid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mgmtid_.Get();
}
inline void mgmtMsmtSettings::_internal_set_mgmtid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mgmtid_.Set(value, GetArena());
}
inline std::string* mgmtMsmtSettings::_internal_mutable_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mgmtid_.Mutable( GetArena());
}
inline std::string* mgmtMsmtSettings::release_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtMsmtSettings.mgmtId)
  return _impl_.mgmtid_.Release();
}
inline void mgmtMsmtSettings::set_allocated_mgmtid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgmtid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mgmtid_.IsDefault()) {
          _impl_.mgmtid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtMsmtSettings.mgmtId)
}

// string pw = 7;
inline void mgmtMsmtSettings::clear_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pw_.ClearToEmpty();
}
inline const std::string& mgmtMsmtSettings::pw() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtMsmtSettings.pw)
  return _internal_pw();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtMsmtSettings::set_pw(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pw_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtMsmtSettings.pw)
}
inline std::string* mgmtMsmtSettings::mutable_pw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtMsmtSettings.pw)
  return _s;
}
inline const std::string& mgmtMsmtSettings::_internal_pw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pw_.Get();
}
inline void mgmtMsmtSettings::_internal_set_pw(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pw_.Set(value, GetArena());
}
inline std::string* mgmtMsmtSettings::_internal_mutable_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.pw_.Mutable( GetArena());
}
inline std::string* mgmtMsmtSettings::release_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtMsmtSettings.pw)
  return _impl_.pw_.Release();
}
inline void mgmtMsmtSettings::set_allocated_pw(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pw_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pw_.IsDefault()) {
          _impl_.pw_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtMsmtSettings.pw)
}

// -------------------------------------------------------------------

// mgmtRequest

// string clientUid = 1;
inline void mgmtRequest::clear_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.ClearToEmpty();
}
inline const std::string& mgmtRequest::clientuid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtRequest.clientUid)
  return _internal_clientuid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtRequest::set_clientuid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtRequest.clientUid)
}
inline std::string* mgmtRequest::mutable_clientuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_clientuid();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtRequest.clientUid)
  return _s;
}
inline const std::string& mgmtRequest::_internal_clientuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clientuid_.Get();
}
inline void mgmtRequest::_internal_set_clientuid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.clientuid_.Set(value, GetArena());
}
inline std::string* mgmtRequest::_internal_mutable_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.clientuid_.Mutable( GetArena());
}
inline std::string* mgmtRequest::release_clientuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtRequest.clientUid)
  return _impl_.clientuid_.Release();
}
inline void mgmtRequest::set_allocated_clientuid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clientuid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.clientuid_.IsDefault()) {
          _impl_.clientuid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtRequest.clientUid)
}

// .autopapi.srvRequestType msgType = 2;
inline void mgmtRequest::clear_msgtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgtype_ = 0;
}
inline ::autopapi::srvRequestType mgmtRequest::msgtype() const {
  // @@protoc_insertion_point(field_get:autopapi.mgmtRequest.msgType)
  return _internal_msgtype();
}
inline void mgmtRequest::set_msgtype(::autopapi::srvRequestType value) {
  _internal_set_msgtype(value);
  // @@protoc_insertion_point(field_set:autopapi.mgmtRequest.msgType)
}
inline ::autopapi::srvRequestType mgmtRequest::_internal_msgtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::autopapi::srvRequestType>(_impl_.msgtype_);
}
inline void mgmtRequest::_internal_set_msgtype(::autopapi::srvRequestType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msgtype_ = value;
}

// optional string requestBody = 3;
inline bool mgmtRequest::has_requestbody() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void mgmtRequest::clear_requestbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestbody_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& mgmtRequest::requestbody() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtRequest.requestBody)
  return _internal_requestbody();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtRequest::set_requestbody(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.requestbody_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtRequest.requestBody)
}
inline std::string* mgmtRequest::mutable_requestbody() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_requestbody();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtRequest.requestBody)
  return _s;
}
inline const std::string& mgmtRequest::_internal_requestbody() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestbody_.Get();
}
inline void mgmtRequest::_internal_set_requestbody(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.requestbody_.Set(value, GetArena());
}
inline std::string* mgmtRequest::_internal_mutable_requestbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.requestbody_.Mutable( GetArena());
}
inline std::string* mgmtRequest::release_requestbody() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtRequest.requestBody)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.requestbody_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.requestbody_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void mgmtRequest::set_allocated_requestbody(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.requestbody_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.requestbody_.IsDefault()) {
          _impl_.requestbody_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtRequest.requestBody)
}

// optional uint32 requestNo = 4;
inline bool mgmtRequest::has_requestno() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void mgmtRequest::clear_requestno() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.requestno_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t mgmtRequest::requestno() const {
  // @@protoc_insertion_point(field_get:autopapi.mgmtRequest.requestNo)
  return _internal_requestno();
}
inline void mgmtRequest::set_requestno(::uint32_t value) {
  _internal_set_requestno(value);
  // @@protoc_insertion_point(field_set:autopapi.mgmtRequest.requestNo)
}
inline ::uint32_t mgmtRequest::_internal_requestno() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.requestno_;
}
inline void mgmtRequest::_internal_set_requestno(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.requestno_ = value;
}

// string mgmtId = 5;
inline void mgmtRequest::clear_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgmtid_.ClearToEmpty();
}
inline const std::string& mgmtRequest::mgmtid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtRequest.mgmtId)
  return _internal_mgmtid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtRequest::set_mgmtid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mgmtid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtRequest.mgmtId)
}
inline std::string* mgmtRequest::mutable_mgmtid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mgmtid();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtRequest.mgmtId)
  return _s;
}
inline const std::string& mgmtRequest::_internal_mgmtid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mgmtid_.Get();
}
inline void mgmtRequest::_internal_set_mgmtid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mgmtid_.Set(value, GetArena());
}
inline std::string* mgmtRequest::_internal_mutable_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.mgmtid_.Mutable( GetArena());
}
inline std::string* mgmtRequest::release_mgmtid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtRequest.mgmtId)
  return _impl_.mgmtid_.Release();
}
inline void mgmtRequest::set_allocated_mgmtid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgmtid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mgmtid_.IsDefault()) {
          _impl_.mgmtid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtRequest.mgmtId)
}

// string pw = 6;
inline void mgmtRequest::clear_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pw_.ClearToEmpty();
}
inline const std::string& mgmtRequest::pw() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:autopapi.mgmtRequest.pw)
  return _internal_pw();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void mgmtRequest::set_pw(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pw_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:autopapi.mgmtRequest.pw)
}
inline std::string* mgmtRequest::mutable_pw() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pw();
  // @@protoc_insertion_point(field_mutable:autopapi.mgmtRequest.pw)
  return _s;
}
inline const std::string& mgmtRequest::_internal_pw() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pw_.Get();
}
inline void mgmtRequest::_internal_set_pw(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pw_.Set(value, GetArena());
}
inline std::string* mgmtRequest::_internal_mutable_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.pw_.Mutable( GetArena());
}
inline std::string* mgmtRequest::release_pw() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:autopapi.mgmtRequest.pw)
  return _impl_.pw_.Release();
}
inline void mgmtRequest::set_allocated_pw(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pw_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pw_.IsDefault()) {
          _impl_.pw_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:autopapi.mgmtRequest.pw)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace autopapi


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::autopapi::srvRequestType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::autopapi::srvRequestType>() {
  return ::autopapi::srvRequestType_descriptor();
}
template <>
struct is_proto_enum<::autopapi::clientResponseType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::autopapi::clientResponseType>() {
  return ::autopapi::clientResponseType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2eproto_2epb_2eh
