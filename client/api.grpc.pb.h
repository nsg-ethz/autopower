// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: api.proto
#ifndef GRPC_api_2eproto__INCLUDED
#define GRPC_api_2eproto__INCLUDED

#include "api.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace autopapi {

class CMeasurementApi final {
 public:
  static constexpr char const* service_full_name() {
    return "autopapi.CMeasurementApi";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // / -- autopower device calls -- ///
    //
    // registers on server and listens on stream for commands from server
    // @returns command stream from server
    std::unique_ptr< ::grpc::ClientReaderInterface< ::autopapi::srvRequest>> registerClient(::grpc::ClientContext* context, const ::autopapi::clientUid& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::autopapi::srvRequest>>(registerClientRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::autopapi::srvRequest>> AsyncregisterClient(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::autopapi::srvRequest>>(AsyncregisterClientRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::autopapi::srvRequest>> PrepareAsyncregisterClient(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::autopapi::srvRequest>>(PrepareAsyncregisterClientRaw(context, request, cq));
    }
    // informs server of success/failure of a srvRequest
    // @returns a clientResponse stream to some issued srvRequests
    virtual ::grpc::Status putClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::autopapi::nothing* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>> AsyncputClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>>(AsyncputClientResponseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>> PrepareAsyncputClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>>(PrepareAsyncputClientResponseRaw(context, request, cq));
    }
    // upload file list to server
    // @param stream of all measurement names to the server
    std::unique_ptr< ::grpc::ClientWriterInterface< ::autopapi::msmtName>> putMeasurementList(::grpc::ClientContext* context, ::autopapi::nothing* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::autopapi::msmtName>>(putMeasurementListRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtName>> AsyncputMeasurementList(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtName>>(AsyncputMeasurementListRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtName>> PrepareAsyncputMeasurementList(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtName>>(PrepareAsyncputMeasurementListRaw(context, response, cq));
    }
    // upload finished measurement to server
    // @param msmtSample stream is the file content requested by the server initially
    std::unique_ptr< ::grpc::ClientWriterInterface< ::autopapi::msmtSample>> putMeasurement(::grpc::ClientContext* context, ::autopapi::nothing* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::autopapi::msmtSample>>(putMeasurementRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtSample>> AsyncputMeasurement(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtSample>>(AsyncputMeasurementRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtSample>> PrepareAsyncputMeasurement(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtSample>>(PrepareAsyncputMeasurementRaw(context, response, cq));
    }
    // gets all necessary data for measurement and then immediately starts the measurement
    // @returns measurement settings
    virtual ::grpc::Status getMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::autopapi::msmtSettings* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::msmtSettings>> AsyncgetMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::msmtSettings>>(AsyncgetMsmtSttngsAndStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::msmtSettings>> PrepareAsyncgetMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::msmtSettings>>(PrepareAsyncgetMsmtSttngsAndStartRaw(context, request, cq));
    }
    // informs remote server of local status or error
    // @param the cmStatus informing the server
    virtual ::grpc::Status putStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::autopapi::nothing* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>> AsyncputStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>>(AsyncputStatusMsgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>> PrepareAsyncputStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>>(PrepareAsyncputStatusMsgRaw(context, request, cq));
    }
    // / -- management calls for external CLI/plotter -- ///
    //
    // gets the list of currently registered clients - they may not be currenly connected
    // @returns stream of client UIDs
    std::unique_ptr< ::grpc::ClientReaderInterface< ::autopapi::clientUid>> getLoggedInClients(::grpc::ClientContext* context, const ::autopapi::nothing& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::autopapi::clientUid>>(getLoggedInClientsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::autopapi::clientUid>> AsyncgetLoggedInClients(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::autopapi::clientUid>>(AsyncgetLoggedInClientsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::autopapi::clientUid>> PrepareAsyncgetLoggedInClients(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::autopapi::clientUid>>(PrepareAsyncgetLoggedInClientsRaw(context, request, cq));
    }
    // sets measurement settings of a client locally on the server but does not start a measurement yet
    // @param measurement settings for a device
    virtual ::grpc::Status setMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::autopapi::nothing* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>> AsyncsetMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>>(AsyncsetMsmtSttingsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>> PrepareAsyncsetMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>>(PrepareAsyncsetMsmtSttingsRaw(context, request, cq));
    }
    // request the server to relay a request to an autopower device
    // @param a request from the server to the autopower device
    // @returns a response of the client
    virtual ::grpc::Status issueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::autopapi::clientResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::clientResponse>> AsyncissueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::clientResponse>>(AsyncissueRequestToClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::clientResponse>> PrepareAsyncissueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::clientResponse>>(PrepareAsyncissueRequestToClientRaw(context, request, cq));
    }
    // get status and error messages from server
    // @returns stream of error messages from any client
    virtual ::grpc::Status getNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::autopapi::cmMCode* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::cmMCode>> AsyncgetNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::cmMCode>>(AsyncgetNextMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::cmMCode>> PrepareAsyncgetNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::cmMCode>>(PrepareAsyncgetNextMessageRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // / -- autopower device calls -- ///
      //
      // registers on server and listens on stream for commands from server
      // @returns command stream from server
      virtual void registerClient(::grpc::ClientContext* context, const ::autopapi::clientUid* request, ::grpc::ClientReadReactor< ::autopapi::srvRequest>* reactor) = 0;
      // informs server of success/failure of a srvRequest
      // @returns a clientResponse stream to some issued srvRequests
      virtual void putClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse* request, ::autopapi::nothing* response, std::function<void(::grpc::Status)>) = 0;
      virtual void putClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse* request, ::autopapi::nothing* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // upload file list to server
      // @param stream of all measurement names to the server
      virtual void putMeasurementList(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::ClientWriteReactor< ::autopapi::msmtName>* reactor) = 0;
      // upload finished measurement to server
      // @param msmtSample stream is the file content requested by the server initially
      virtual void putMeasurement(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::ClientWriteReactor< ::autopapi::msmtSample>* reactor) = 0;
      // gets all necessary data for measurement and then immediately starts the measurement
      // @returns measurement settings
      virtual void getMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid* request, ::autopapi::msmtSettings* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid* request, ::autopapi::msmtSettings* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // informs remote server of local status or error
      // @param the cmStatus informing the server
      virtual void putStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode* request, ::autopapi::nothing* response, std::function<void(::grpc::Status)>) = 0;
      virtual void putStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode* request, ::autopapi::nothing* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // / -- management calls for external CLI/plotter -- ///
      //
      // gets the list of currently registered clients - they may not be currenly connected
      // @returns stream of client UIDs
      virtual void getLoggedInClients(::grpc::ClientContext* context, const ::autopapi::nothing* request, ::grpc::ClientReadReactor< ::autopapi::clientUid>* reactor) = 0;
      // sets measurement settings of a client locally on the server but does not start a measurement yet
      // @param measurement settings for a device
      virtual void setMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings* request, ::autopapi::nothing* response, std::function<void(::grpc::Status)>) = 0;
      virtual void setMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings* request, ::autopapi::nothing* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // request the server to relay a request to an autopower device
      // @param a request from the server to the autopower device
      // @returns a response of the client
      virtual void issueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest* request, ::autopapi::clientResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void issueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest* request, ::autopapi::clientResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // get status and error messages from server
      // @returns stream of error messages from any client
      virtual void getNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing* request, ::autopapi::cmMCode* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing* request, ::autopapi::cmMCode* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderInterface< ::autopapi::srvRequest>* registerClientRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::autopapi::srvRequest>* AsyncregisterClientRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::autopapi::srvRequest>* PrepareAsyncregisterClientRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>* AsyncputClientResponseRaw(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>* PrepareAsyncputClientResponseRaw(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::autopapi::msmtName>* putMeasurementListRaw(::grpc::ClientContext* context, ::autopapi::nothing* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtName>* AsyncputMeasurementListRaw(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtName>* PrepareAsyncputMeasurementListRaw(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::autopapi::msmtSample>* putMeasurementRaw(::grpc::ClientContext* context, ::autopapi::nothing* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtSample>* AsyncputMeasurementRaw(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::autopapi::msmtSample>* PrepareAsyncputMeasurementRaw(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::msmtSettings>* AsyncgetMsmtSttngsAndStartRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::msmtSettings>* PrepareAsyncgetMsmtSttngsAndStartRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>* AsyncputStatusMsgRaw(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>* PrepareAsyncputStatusMsgRaw(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::autopapi::clientUid>* getLoggedInClientsRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::autopapi::clientUid>* AsyncgetLoggedInClientsRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::autopapi::clientUid>* PrepareAsyncgetLoggedInClientsRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>* AsyncsetMsmtSttingsRaw(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::nothing>* PrepareAsyncsetMsmtSttingsRaw(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::clientResponse>* AsyncissueRequestToClientRaw(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::clientResponse>* PrepareAsyncissueRequestToClientRaw(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::cmMCode>* AsyncgetNextMessageRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::autopapi::cmMCode>* PrepareAsyncgetNextMessageRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReader< ::autopapi::srvRequest>> registerClient(::grpc::ClientContext* context, const ::autopapi::clientUid& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::autopapi::srvRequest>>(registerClientRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::autopapi::srvRequest>> AsyncregisterClient(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::autopapi::srvRequest>>(AsyncregisterClientRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::autopapi::srvRequest>> PrepareAsyncregisterClient(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::autopapi::srvRequest>>(PrepareAsyncregisterClientRaw(context, request, cq));
    }
    ::grpc::Status putClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::autopapi::nothing* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>> AsyncputClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>>(AsyncputClientResponseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>> PrepareAsyncputClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>>(PrepareAsyncputClientResponseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::autopapi::msmtName>> putMeasurementList(::grpc::ClientContext* context, ::autopapi::nothing* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::autopapi::msmtName>>(putMeasurementListRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::autopapi::msmtName>> AsyncputMeasurementList(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::autopapi::msmtName>>(AsyncputMeasurementListRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::autopapi::msmtName>> PrepareAsyncputMeasurementList(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::autopapi::msmtName>>(PrepareAsyncputMeasurementListRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::autopapi::msmtSample>> putMeasurement(::grpc::ClientContext* context, ::autopapi::nothing* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::autopapi::msmtSample>>(putMeasurementRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::autopapi::msmtSample>> AsyncputMeasurement(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::autopapi::msmtSample>>(AsyncputMeasurementRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::autopapi::msmtSample>> PrepareAsyncputMeasurement(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::autopapi::msmtSample>>(PrepareAsyncputMeasurementRaw(context, response, cq));
    }
    ::grpc::Status getMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::autopapi::msmtSettings* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::msmtSettings>> AsyncgetMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::msmtSettings>>(AsyncgetMsmtSttngsAndStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::msmtSettings>> PrepareAsyncgetMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::msmtSettings>>(PrepareAsyncgetMsmtSttngsAndStartRaw(context, request, cq));
    }
    ::grpc::Status putStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::autopapi::nothing* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>> AsyncputStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>>(AsyncputStatusMsgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>> PrepareAsyncputStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>>(PrepareAsyncputStatusMsgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::autopapi::clientUid>> getLoggedInClients(::grpc::ClientContext* context, const ::autopapi::nothing& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::autopapi::clientUid>>(getLoggedInClientsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::autopapi::clientUid>> AsyncgetLoggedInClients(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::autopapi::clientUid>>(AsyncgetLoggedInClientsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::autopapi::clientUid>> PrepareAsyncgetLoggedInClients(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::autopapi::clientUid>>(PrepareAsyncgetLoggedInClientsRaw(context, request, cq));
    }
    ::grpc::Status setMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::autopapi::nothing* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>> AsyncsetMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>>(AsyncsetMsmtSttingsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>> PrepareAsyncsetMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>>(PrepareAsyncsetMsmtSttingsRaw(context, request, cq));
    }
    ::grpc::Status issueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::autopapi::clientResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::clientResponse>> AsyncissueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::clientResponse>>(AsyncissueRequestToClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::clientResponse>> PrepareAsyncissueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::clientResponse>>(PrepareAsyncissueRequestToClientRaw(context, request, cq));
    }
    ::grpc::Status getNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::autopapi::cmMCode* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::cmMCode>> AsyncgetNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::cmMCode>>(AsyncgetNextMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::cmMCode>> PrepareAsyncgetNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::autopapi::cmMCode>>(PrepareAsyncgetNextMessageRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void registerClient(::grpc::ClientContext* context, const ::autopapi::clientUid* request, ::grpc::ClientReadReactor< ::autopapi::srvRequest>* reactor) override;
      void putClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse* request, ::autopapi::nothing* response, std::function<void(::grpc::Status)>) override;
      void putClientResponse(::grpc::ClientContext* context, const ::autopapi::clientResponse* request, ::autopapi::nothing* response, ::grpc::ClientUnaryReactor* reactor) override;
      void putMeasurementList(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::ClientWriteReactor< ::autopapi::msmtName>* reactor) override;
      void putMeasurement(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::ClientWriteReactor< ::autopapi::msmtSample>* reactor) override;
      void getMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid* request, ::autopapi::msmtSettings* response, std::function<void(::grpc::Status)>) override;
      void getMsmtSttngsAndStart(::grpc::ClientContext* context, const ::autopapi::clientUid* request, ::autopapi::msmtSettings* response, ::grpc::ClientUnaryReactor* reactor) override;
      void putStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode* request, ::autopapi::nothing* response, std::function<void(::grpc::Status)>) override;
      void putStatusMsg(::grpc::ClientContext* context, const ::autopapi::cmMCode* request, ::autopapi::nothing* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getLoggedInClients(::grpc::ClientContext* context, const ::autopapi::nothing* request, ::grpc::ClientReadReactor< ::autopapi::clientUid>* reactor) override;
      void setMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings* request, ::autopapi::nothing* response, std::function<void(::grpc::Status)>) override;
      void setMsmtSttings(::grpc::ClientContext* context, const ::autopapi::msmtSettings* request, ::autopapi::nothing* response, ::grpc::ClientUnaryReactor* reactor) override;
      void issueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest* request, ::autopapi::clientResponse* response, std::function<void(::grpc::Status)>) override;
      void issueRequestToClient(::grpc::ClientContext* context, const ::autopapi::srvRequest* request, ::autopapi::clientResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing* request, ::autopapi::cmMCode* response, std::function<void(::grpc::Status)>) override;
      void getNextMessage(::grpc::ClientContext* context, const ::autopapi::nothing* request, ::autopapi::cmMCode* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReader< ::autopapi::srvRequest>* registerClientRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request) override;
    ::grpc::ClientAsyncReader< ::autopapi::srvRequest>* AsyncregisterClientRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::autopapi::srvRequest>* PrepareAsyncregisterClientRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>* AsyncputClientResponseRaw(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>* PrepareAsyncputClientResponseRaw(::grpc::ClientContext* context, const ::autopapi::clientResponse& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::autopapi::msmtName>* putMeasurementListRaw(::grpc::ClientContext* context, ::autopapi::nothing* response) override;
    ::grpc::ClientAsyncWriter< ::autopapi::msmtName>* AsyncputMeasurementListRaw(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::autopapi::msmtName>* PrepareAsyncputMeasurementListRaw(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::autopapi::msmtSample>* putMeasurementRaw(::grpc::ClientContext* context, ::autopapi::nothing* response) override;
    ::grpc::ClientAsyncWriter< ::autopapi::msmtSample>* AsyncputMeasurementRaw(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::autopapi::msmtSample>* PrepareAsyncputMeasurementRaw(::grpc::ClientContext* context, ::autopapi::nothing* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::msmtSettings>* AsyncgetMsmtSttngsAndStartRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::msmtSettings>* PrepareAsyncgetMsmtSttngsAndStartRaw(::grpc::ClientContext* context, const ::autopapi::clientUid& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>* AsyncputStatusMsgRaw(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>* PrepareAsyncputStatusMsgRaw(::grpc::ClientContext* context, const ::autopapi::cmMCode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::autopapi::clientUid>* getLoggedInClientsRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request) override;
    ::grpc::ClientAsyncReader< ::autopapi::clientUid>* AsyncgetLoggedInClientsRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::autopapi::clientUid>* PrepareAsyncgetLoggedInClientsRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>* AsyncsetMsmtSttingsRaw(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::nothing>* PrepareAsyncsetMsmtSttingsRaw(::grpc::ClientContext* context, const ::autopapi::msmtSettings& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::clientResponse>* AsyncissueRequestToClientRaw(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::clientResponse>* PrepareAsyncissueRequestToClientRaw(::grpc::ClientContext* context, const ::autopapi::srvRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::cmMCode>* AsyncgetNextMessageRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::autopapi::cmMCode>* PrepareAsyncgetNextMessageRaw(::grpc::ClientContext* context, const ::autopapi::nothing& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_registerClient_;
    const ::grpc::internal::RpcMethod rpcmethod_putClientResponse_;
    const ::grpc::internal::RpcMethod rpcmethod_putMeasurementList_;
    const ::grpc::internal::RpcMethod rpcmethod_putMeasurement_;
    const ::grpc::internal::RpcMethod rpcmethod_getMsmtSttngsAndStart_;
    const ::grpc::internal::RpcMethod rpcmethod_putStatusMsg_;
    const ::grpc::internal::RpcMethod rpcmethod_getLoggedInClients_;
    const ::grpc::internal::RpcMethod rpcmethod_setMsmtSttings_;
    const ::grpc::internal::RpcMethod rpcmethod_issueRequestToClient_;
    const ::grpc::internal::RpcMethod rpcmethod_getNextMessage_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // / -- autopower device calls -- ///
    //
    // registers on server and listens on stream for commands from server
    // @returns command stream from server
    virtual ::grpc::Status registerClient(::grpc::ServerContext* context, const ::autopapi::clientUid* request, ::grpc::ServerWriter< ::autopapi::srvRequest>* writer);
    // informs server of success/failure of a srvRequest
    // @returns a clientResponse stream to some issued srvRequests
    virtual ::grpc::Status putClientResponse(::grpc::ServerContext* context, const ::autopapi::clientResponse* request, ::autopapi::nothing* response);
    // upload file list to server
    // @param stream of all measurement names to the server
    virtual ::grpc::Status putMeasurementList(::grpc::ServerContext* context, ::grpc::ServerReader< ::autopapi::msmtName>* reader, ::autopapi::nothing* response);
    // upload finished measurement to server
    // @param msmtSample stream is the file content requested by the server initially
    virtual ::grpc::Status putMeasurement(::grpc::ServerContext* context, ::grpc::ServerReader< ::autopapi::msmtSample>* reader, ::autopapi::nothing* response);
    // gets all necessary data for measurement and then immediately starts the measurement
    // @returns measurement settings
    virtual ::grpc::Status getMsmtSttngsAndStart(::grpc::ServerContext* context, const ::autopapi::clientUid* request, ::autopapi::msmtSettings* response);
    // informs remote server of local status or error
    // @param the cmStatus informing the server
    virtual ::grpc::Status putStatusMsg(::grpc::ServerContext* context, const ::autopapi::cmMCode* request, ::autopapi::nothing* response);
    // / -- management calls for external CLI/plotter -- ///
    //
    // gets the list of currently registered clients - they may not be currenly connected
    // @returns stream of client UIDs
    virtual ::grpc::Status getLoggedInClients(::grpc::ServerContext* context, const ::autopapi::nothing* request, ::grpc::ServerWriter< ::autopapi::clientUid>* writer);
    // sets measurement settings of a client locally on the server but does not start a measurement yet
    // @param measurement settings for a device
    virtual ::grpc::Status setMsmtSttings(::grpc::ServerContext* context, const ::autopapi::msmtSettings* request, ::autopapi::nothing* response);
    // request the server to relay a request to an autopower device
    // @param a request from the server to the autopower device
    // @returns a response of the client
    virtual ::grpc::Status issueRequestToClient(::grpc::ServerContext* context, const ::autopapi::srvRequest* request, ::autopapi::clientResponse* response);
    // get status and error messages from server
    // @returns stream of error messages from any client
    virtual ::grpc::Status getNextMessage(::grpc::ServerContext* context, const ::autopapi::nothing* request, ::autopapi::cmMCode* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_registerClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_registerClient() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_registerClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerClient(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::grpc::ServerWriter< ::autopapi::srvRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterClient(::grpc::ServerContext* context, ::autopapi::clientUid* request, ::grpc::ServerAsyncWriter< ::autopapi::srvRequest>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_putClientResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_putClientResponse() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_putClientResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putClientResponse(::grpc::ServerContext* /*context*/, const ::autopapi::clientResponse* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestputClientResponse(::grpc::ServerContext* context, ::autopapi::clientResponse* request, ::grpc::ServerAsyncResponseWriter< ::autopapi::nothing>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_putMeasurementList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_putMeasurementList() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_putMeasurementList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurementList(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtName>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestputMeasurementList(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::autopapi::nothing, ::autopapi::msmtName>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_putMeasurement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_putMeasurement() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_putMeasurement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurement(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtSample>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestputMeasurement(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::autopapi::nothing, ::autopapi::msmtSample>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(3, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getMsmtSttngsAndStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getMsmtSttngsAndStart() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_getMsmtSttngsAndStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMsmtSttngsAndStart(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::autopapi::msmtSettings* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetMsmtSttngsAndStart(::grpc::ServerContext* context, ::autopapi::clientUid* request, ::grpc::ServerAsyncResponseWriter< ::autopapi::msmtSettings>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_putStatusMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_putStatusMsg() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_putStatusMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putStatusMsg(::grpc::ServerContext* /*context*/, const ::autopapi::cmMCode* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestputStatusMsg(::grpc::ServerContext* context, ::autopapi::cmMCode* request, ::grpc::ServerAsyncResponseWriter< ::autopapi::nothing>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getLoggedInClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getLoggedInClients() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_getLoggedInClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLoggedInClients(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::grpc::ServerWriter< ::autopapi::clientUid>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLoggedInClients(::grpc::ServerContext* context, ::autopapi::nothing* request, ::grpc::ServerAsyncWriter< ::autopapi::clientUid>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_setMsmtSttings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_setMsmtSttings() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_setMsmtSttings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMsmtSttings(::grpc::ServerContext* /*context*/, const ::autopapi::msmtSettings* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetMsmtSttings(::grpc::ServerContext* context, ::autopapi::msmtSettings* request, ::grpc::ServerAsyncResponseWriter< ::autopapi::nothing>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_issueRequestToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_issueRequestToClient() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_issueRequestToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status issueRequestToClient(::grpc::ServerContext* /*context*/, const ::autopapi::srvRequest* /*request*/, ::autopapi::clientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestissueRequestToClient(::grpc::ServerContext* context, ::autopapi::srvRequest* request, ::grpc::ServerAsyncResponseWriter< ::autopapi::clientResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getNextMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getNextMessage() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_getNextMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNextMessage(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::autopapi::cmMCode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNextMessage(::grpc::ServerContext* context, ::autopapi::nothing* request, ::grpc::ServerAsyncResponseWriter< ::autopapi::cmMCode>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_registerClient<WithAsyncMethod_putClientResponse<WithAsyncMethod_putMeasurementList<WithAsyncMethod_putMeasurement<WithAsyncMethod_getMsmtSttngsAndStart<WithAsyncMethod_putStatusMsg<WithAsyncMethod_getLoggedInClients<WithAsyncMethod_setMsmtSttings<WithAsyncMethod_issueRequestToClient<WithAsyncMethod_getNextMessage<Service > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_registerClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_registerClient() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::autopapi::clientUid, ::autopapi::srvRequest>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::autopapi::clientUid* request) { return this->registerClient(context, request); }));
    }
    ~WithCallbackMethod_registerClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerClient(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::grpc::ServerWriter< ::autopapi::srvRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::autopapi::srvRequest>* registerClient(
      ::grpc::CallbackServerContext* /*context*/, const ::autopapi::clientUid* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_putClientResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_putClientResponse() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::autopapi::clientResponse, ::autopapi::nothing>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::autopapi::clientResponse* request, ::autopapi::nothing* response) { return this->putClientResponse(context, request, response); }));}
    void SetMessageAllocatorFor_putClientResponse(
        ::grpc::MessageAllocator< ::autopapi::clientResponse, ::autopapi::nothing>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::autopapi::clientResponse, ::autopapi::nothing>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_putClientResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putClientResponse(::grpc::ServerContext* /*context*/, const ::autopapi::clientResponse* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* putClientResponse(
      ::grpc::CallbackServerContext* /*context*/, const ::autopapi::clientResponse* /*request*/, ::autopapi::nothing* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_putMeasurementList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_putMeasurementList() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackClientStreamingHandler< ::autopapi::msmtName, ::autopapi::nothing>(
            [this](
                   ::grpc::CallbackServerContext* context, ::autopapi::nothing* response) { return this->putMeasurementList(context, response); }));
    }
    ~WithCallbackMethod_putMeasurementList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurementList(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtName>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::autopapi::msmtName>* putMeasurementList(
      ::grpc::CallbackServerContext* /*context*/, ::autopapi::nothing* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_putMeasurement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_putMeasurement() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackClientStreamingHandler< ::autopapi::msmtSample, ::autopapi::nothing>(
            [this](
                   ::grpc::CallbackServerContext* context, ::autopapi::nothing* response) { return this->putMeasurement(context, response); }));
    }
    ~WithCallbackMethod_putMeasurement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurement(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtSample>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::autopapi::msmtSample>* putMeasurement(
      ::grpc::CallbackServerContext* /*context*/, ::autopapi::nothing* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getMsmtSttngsAndStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getMsmtSttngsAndStart() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::autopapi::clientUid, ::autopapi::msmtSettings>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::autopapi::clientUid* request, ::autopapi::msmtSettings* response) { return this->getMsmtSttngsAndStart(context, request, response); }));}
    void SetMessageAllocatorFor_getMsmtSttngsAndStart(
        ::grpc::MessageAllocator< ::autopapi::clientUid, ::autopapi::msmtSettings>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::autopapi::clientUid, ::autopapi::msmtSettings>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getMsmtSttngsAndStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMsmtSttngsAndStart(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::autopapi::msmtSettings* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getMsmtSttngsAndStart(
      ::grpc::CallbackServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::autopapi::msmtSettings* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_putStatusMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_putStatusMsg() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::autopapi::cmMCode, ::autopapi::nothing>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::autopapi::cmMCode* request, ::autopapi::nothing* response) { return this->putStatusMsg(context, request, response); }));}
    void SetMessageAllocatorFor_putStatusMsg(
        ::grpc::MessageAllocator< ::autopapi::cmMCode, ::autopapi::nothing>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::autopapi::cmMCode, ::autopapi::nothing>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_putStatusMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putStatusMsg(::grpc::ServerContext* /*context*/, const ::autopapi::cmMCode* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* putStatusMsg(
      ::grpc::CallbackServerContext* /*context*/, const ::autopapi::cmMCode* /*request*/, ::autopapi::nothing* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getLoggedInClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getLoggedInClients() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::autopapi::nothing, ::autopapi::clientUid>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::autopapi::nothing* request) { return this->getLoggedInClients(context, request); }));
    }
    ~WithCallbackMethod_getLoggedInClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLoggedInClients(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::grpc::ServerWriter< ::autopapi::clientUid>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::autopapi::clientUid>* getLoggedInClients(
      ::grpc::CallbackServerContext* /*context*/, const ::autopapi::nothing* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_setMsmtSttings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_setMsmtSttings() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::autopapi::msmtSettings, ::autopapi::nothing>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::autopapi::msmtSettings* request, ::autopapi::nothing* response) { return this->setMsmtSttings(context, request, response); }));}
    void SetMessageAllocatorFor_setMsmtSttings(
        ::grpc::MessageAllocator< ::autopapi::msmtSettings, ::autopapi::nothing>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::autopapi::msmtSettings, ::autopapi::nothing>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_setMsmtSttings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMsmtSttings(::grpc::ServerContext* /*context*/, const ::autopapi::msmtSettings* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setMsmtSttings(
      ::grpc::CallbackServerContext* /*context*/, const ::autopapi::msmtSettings* /*request*/, ::autopapi::nothing* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_issueRequestToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_issueRequestToClient() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::autopapi::srvRequest, ::autopapi::clientResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::autopapi::srvRequest* request, ::autopapi::clientResponse* response) { return this->issueRequestToClient(context, request, response); }));}
    void SetMessageAllocatorFor_issueRequestToClient(
        ::grpc::MessageAllocator< ::autopapi::srvRequest, ::autopapi::clientResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::autopapi::srvRequest, ::autopapi::clientResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_issueRequestToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status issueRequestToClient(::grpc::ServerContext* /*context*/, const ::autopapi::srvRequest* /*request*/, ::autopapi::clientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* issueRequestToClient(
      ::grpc::CallbackServerContext* /*context*/, const ::autopapi::srvRequest* /*request*/, ::autopapi::clientResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getNextMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getNextMessage() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::autopapi::nothing, ::autopapi::cmMCode>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::autopapi::nothing* request, ::autopapi::cmMCode* response) { return this->getNextMessage(context, request, response); }));}
    void SetMessageAllocatorFor_getNextMessage(
        ::grpc::MessageAllocator< ::autopapi::nothing, ::autopapi::cmMCode>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::autopapi::nothing, ::autopapi::cmMCode>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getNextMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNextMessage(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::autopapi::cmMCode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getNextMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::autopapi::cmMCode* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_registerClient<WithCallbackMethod_putClientResponse<WithCallbackMethod_putMeasurementList<WithCallbackMethod_putMeasurement<WithCallbackMethod_getMsmtSttngsAndStart<WithCallbackMethod_putStatusMsg<WithCallbackMethod_getLoggedInClients<WithCallbackMethod_setMsmtSttings<WithCallbackMethod_issueRequestToClient<WithCallbackMethod_getNextMessage<Service > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_registerClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_registerClient() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_registerClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerClient(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::grpc::ServerWriter< ::autopapi::srvRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_putClientResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_putClientResponse() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_putClientResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putClientResponse(::grpc::ServerContext* /*context*/, const ::autopapi::clientResponse* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_putMeasurementList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_putMeasurementList() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_putMeasurementList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurementList(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtName>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_putMeasurement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_putMeasurement() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_putMeasurement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurement(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtSample>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getMsmtSttngsAndStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getMsmtSttngsAndStart() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_getMsmtSttngsAndStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMsmtSttngsAndStart(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::autopapi::msmtSettings* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_putStatusMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_putStatusMsg() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_putStatusMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putStatusMsg(::grpc::ServerContext* /*context*/, const ::autopapi::cmMCode* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getLoggedInClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getLoggedInClients() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_getLoggedInClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLoggedInClients(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::grpc::ServerWriter< ::autopapi::clientUid>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_setMsmtSttings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_setMsmtSttings() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_setMsmtSttings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMsmtSttings(::grpc::ServerContext* /*context*/, const ::autopapi::msmtSettings* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_issueRequestToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_issueRequestToClient() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_issueRequestToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status issueRequestToClient(::grpc::ServerContext* /*context*/, const ::autopapi::srvRequest* /*request*/, ::autopapi::clientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getNextMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getNextMessage() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_getNextMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNextMessage(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::autopapi::cmMCode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_registerClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_registerClient() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_registerClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerClient(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::grpc::ServerWriter< ::autopapi::srvRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestregisterClient(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_putClientResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_putClientResponse() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_putClientResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putClientResponse(::grpc::ServerContext* /*context*/, const ::autopapi::clientResponse* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestputClientResponse(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_putMeasurementList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_putMeasurementList() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_putMeasurementList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurementList(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtName>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestputMeasurementList(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(2, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_putMeasurement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_putMeasurement() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_putMeasurement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurement(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtSample>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestputMeasurement(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(3, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getMsmtSttngsAndStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getMsmtSttngsAndStart() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_getMsmtSttngsAndStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMsmtSttngsAndStart(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::autopapi::msmtSettings* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetMsmtSttngsAndStart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_putStatusMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_putStatusMsg() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_putStatusMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putStatusMsg(::grpc::ServerContext* /*context*/, const ::autopapi::cmMCode* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestputStatusMsg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getLoggedInClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getLoggedInClients() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_getLoggedInClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLoggedInClients(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::grpc::ServerWriter< ::autopapi::clientUid>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetLoggedInClients(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_setMsmtSttings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_setMsmtSttings() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_setMsmtSttings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMsmtSttings(::grpc::ServerContext* /*context*/, const ::autopapi::msmtSettings* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsetMsmtSttings(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_issueRequestToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_issueRequestToClient() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_issueRequestToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status issueRequestToClient(::grpc::ServerContext* /*context*/, const ::autopapi::srvRequest* /*request*/, ::autopapi::clientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestissueRequestToClient(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getNextMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getNextMessage() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_getNextMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNextMessage(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::autopapi::cmMCode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetNextMessage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_registerClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_registerClient() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->registerClient(context, request); }));
    }
    ~WithRawCallbackMethod_registerClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status registerClient(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::grpc::ServerWriter< ::autopapi::srvRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* registerClient(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_putClientResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_putClientResponse() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->putClientResponse(context, request, response); }));
    }
    ~WithRawCallbackMethod_putClientResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putClientResponse(::grpc::ServerContext* /*context*/, const ::autopapi::clientResponse* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* putClientResponse(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_putMeasurementList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_putMeasurementList() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->putMeasurementList(context, response); }));
    }
    ~WithRawCallbackMethod_putMeasurementList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurementList(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtName>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* putMeasurementList(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_putMeasurement : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_putMeasurement() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->putMeasurement(context, response); }));
    }
    ~WithRawCallbackMethod_putMeasurement() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putMeasurement(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::autopapi::msmtSample>* /*reader*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* putMeasurement(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getMsmtSttngsAndStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getMsmtSttngsAndStart() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getMsmtSttngsAndStart(context, request, response); }));
    }
    ~WithRawCallbackMethod_getMsmtSttngsAndStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getMsmtSttngsAndStart(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::autopapi::msmtSettings* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getMsmtSttngsAndStart(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_putStatusMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_putStatusMsg() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->putStatusMsg(context, request, response); }));
    }
    ~WithRawCallbackMethod_putStatusMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status putStatusMsg(::grpc::ServerContext* /*context*/, const ::autopapi::cmMCode* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* putStatusMsg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getLoggedInClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getLoggedInClients() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->getLoggedInClients(context, request); }));
    }
    ~WithRawCallbackMethod_getLoggedInClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getLoggedInClients(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::grpc::ServerWriter< ::autopapi::clientUid>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* getLoggedInClients(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_setMsmtSttings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_setMsmtSttings() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->setMsmtSttings(context, request, response); }));
    }
    ~WithRawCallbackMethod_setMsmtSttings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status setMsmtSttings(::grpc::ServerContext* /*context*/, const ::autopapi::msmtSettings* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* setMsmtSttings(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_issueRequestToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_issueRequestToClient() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->issueRequestToClient(context, request, response); }));
    }
    ~WithRawCallbackMethod_issueRequestToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status issueRequestToClient(::grpc::ServerContext* /*context*/, const ::autopapi::srvRequest* /*request*/, ::autopapi::clientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* issueRequestToClient(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getNextMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getNextMessage() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getNextMessage(context, request, response); }));
    }
    ~WithRawCallbackMethod_getNextMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getNextMessage(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::autopapi::cmMCode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getNextMessage(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_putClientResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_putClientResponse() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::autopapi::clientResponse, ::autopapi::nothing>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::autopapi::clientResponse, ::autopapi::nothing>* streamer) {
                       return this->StreamedputClientResponse(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_putClientResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status putClientResponse(::grpc::ServerContext* /*context*/, const ::autopapi::clientResponse* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedputClientResponse(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::autopapi::clientResponse,::autopapi::nothing>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getMsmtSttngsAndStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getMsmtSttngsAndStart() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::autopapi::clientUid, ::autopapi::msmtSettings>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::autopapi::clientUid, ::autopapi::msmtSettings>* streamer) {
                       return this->StreamedgetMsmtSttngsAndStart(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getMsmtSttngsAndStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getMsmtSttngsAndStart(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::autopapi::msmtSettings* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetMsmtSttngsAndStart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::autopapi::clientUid,::autopapi::msmtSettings>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_putStatusMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_putStatusMsg() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::autopapi::cmMCode, ::autopapi::nothing>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::autopapi::cmMCode, ::autopapi::nothing>* streamer) {
                       return this->StreamedputStatusMsg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_putStatusMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status putStatusMsg(::grpc::ServerContext* /*context*/, const ::autopapi::cmMCode* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedputStatusMsg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::autopapi::cmMCode,::autopapi::nothing>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_setMsmtSttings : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_setMsmtSttings() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::autopapi::msmtSettings, ::autopapi::nothing>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::autopapi::msmtSettings, ::autopapi::nothing>* streamer) {
                       return this->StreamedsetMsmtSttings(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_setMsmtSttings() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status setMsmtSttings(::grpc::ServerContext* /*context*/, const ::autopapi::msmtSettings* /*request*/, ::autopapi::nothing* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsetMsmtSttings(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::autopapi::msmtSettings,::autopapi::nothing>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_issueRequestToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_issueRequestToClient() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::autopapi::srvRequest, ::autopapi::clientResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::autopapi::srvRequest, ::autopapi::clientResponse>* streamer) {
                       return this->StreamedissueRequestToClient(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_issueRequestToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status issueRequestToClient(::grpc::ServerContext* /*context*/, const ::autopapi::srvRequest* /*request*/, ::autopapi::clientResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedissueRequestToClient(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::autopapi::srvRequest,::autopapi::clientResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getNextMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getNextMessage() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::autopapi::nothing, ::autopapi::cmMCode>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::autopapi::nothing, ::autopapi::cmMCode>* streamer) {
                       return this->StreamedgetNextMessage(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getNextMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getNextMessage(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::autopapi::cmMCode* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetNextMessage(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::autopapi::nothing,::autopapi::cmMCode>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_putClientResponse<WithStreamedUnaryMethod_getMsmtSttngsAndStart<WithStreamedUnaryMethod_putStatusMsg<WithStreamedUnaryMethod_setMsmtSttings<WithStreamedUnaryMethod_issueRequestToClient<WithStreamedUnaryMethod_getNextMessage<Service > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_registerClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_registerClient() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::autopapi::clientUid, ::autopapi::srvRequest>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::autopapi::clientUid, ::autopapi::srvRequest>* streamer) {
                       return this->StreamedregisterClient(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_registerClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status registerClient(::grpc::ServerContext* /*context*/, const ::autopapi::clientUid* /*request*/, ::grpc::ServerWriter< ::autopapi::srvRequest>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedregisterClient(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::autopapi::clientUid,::autopapi::srvRequest>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_getLoggedInClients : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_getLoggedInClients() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::autopapi::nothing, ::autopapi::clientUid>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::autopapi::nothing, ::autopapi::clientUid>* streamer) {
                       return this->StreamedgetLoggedInClients(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_getLoggedInClients() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getLoggedInClients(::grpc::ServerContext* /*context*/, const ::autopapi::nothing* /*request*/, ::grpc::ServerWriter< ::autopapi::clientUid>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedgetLoggedInClients(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::autopapi::nothing,::autopapi::clientUid>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_registerClient<WithSplitStreamingMethod_getLoggedInClients<Service > > SplitStreamedService;
  typedef WithSplitStreamingMethod_registerClient<WithStreamedUnaryMethod_putClientResponse<WithStreamedUnaryMethod_getMsmtSttngsAndStart<WithStreamedUnaryMethod_putStatusMsg<WithSplitStreamingMethod_getLoggedInClients<WithStreamedUnaryMethod_setMsmtSttings<WithStreamedUnaryMethod_issueRequestToClient<WithStreamedUnaryMethod_getNextMessage<Service > > > > > > > > StreamedService;
};

}  // namespace autopapi


#endif  // GRPC_api_2eproto__INCLUDED
